{
    "contents" : "---\ntitle: \"Stonechat - Geolocator Processing\"\nauthor: \"Simeon Lisovski\"\ndate: \"14 October 2015\"\noutput: html_document\n---\n\nLoad required packages:\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(GeoLight) ## Version 2.0\nlibrary(SGAT)\nlibrary(BAStag)\n\nlibrary(MASS)\nlibrary(maptools)\n  data(wrld_simpl)\n\n## the SGAT and BAStag package can be installed by:\n## library(devtools)\n## install_github(\"SWotherspoon/SGAT\")\n## install_github(\"SWotherspoon/BAStag\")\n```\n\nSet working directory (directory containting folder with .lux files):\n\n```{r}\n# wd <- \"C:/Users/Simeon/Desktop/Stonechat\"\nwd <-  \"C:/Users/slisovsk/Dropbox/Science/Projects/Stonechat\"\n```\n\nRead in and visualise raw data:\n\n```{r}\nd.lux <-  read.table(paste(wd, \"code and data/data/782.lux\", sep=\"/\"), \n                     header = FALSE, skip = 25, \n                     col.names = c(\"Date\",\"Time\", \"Light\"), \n                     colClasses = c(\"character\", \"character\", \"numeric\"))\nd.lux$Date <- as.POSIXct(strptime(paste(d.lux$Date, d.lux$Time), \n                                  \"%d/%m/%Y %H:%M:%S\", tz = \"GMT\"))\nd.lux$Light <- log(d.lux$Light)\n\n\noffset <- 4\nlightImage(d.lux, offset = offset, zlim = c(0, 12))\n\nlon.calib <- 141.4\t\nlat.calib <- 43.1\n\n## Ploting the twilight curves for the calibration site\ntm <- seq(d.lux[1,1], d.lux[nrow(d.lux),1], by = \"day\")\nrise <- rep(c(TRUE, FALSE), length(tm))\n\nc.dat <- data.frame(Twilight = twilight(rep(tm, each = 2), \n                                        lon = lon.calib, lat = lat.calib, \n                                        rise = rise, zenith = 96), Rise = rise)\n\ntsimagePoints(c.dat$Twilight, offset = offset, pch = 16, cex = 0.1,\n               col = ifelse(c.dat$Rise, \"dodgerblue\", \"firebrick\"))\n```\n\nDefine tracking and calibration periods and twilight times (e.g. sunrise/sunset):\n\n```{r}\n## Tracking period (only to be applied at the final run)\n# d.track.tm <- as.POSIXct(locator(n = 2)$x, origin = \"1970-01-01\", tz = \"GMT\")\nd.track.tm <- as.POSIXct(c(\"2014-10-09\", \"2015-01-25\"), tz = \"GMT\")\n# abline(v = d.track.tm, col = \"green\")\n\n## Calibration period\n# d.calib.tm  <- as.POSIXct(locator(n = 2)$x, origin = \"1970-01-01\", tz = \"GMT\")\nd.calib.tm <- as.POSIXct(c(\"2014-05-11\", \"2014-09-28\"), tz = \"GMT\")\nd.calib <- subset(d.lux, (Date>=d.calib.tm[1] & Date<=d.calib.tm[2]))\n\nthreshold <- 0.5\n# twl <- preprocessLight(d.lux, threshold, offset = offset, lmax = 12)\n# dir.create(paste(wd, \"/AnalysisOutput/782\",sep=''))\n# write.csv(twl, paste(wd, \"/AnalysisOutput/782/782_twl.csv\", sep=\"/\"), row.names = FALSE)\n\ntwl <- read.csv(paste(wd, \"/AnalysisOutput/782/782_twl.csv\", sep=\"\"))\ntwl[,1] <- as.POSIXct(twl[,1], tz = \"GMT\")\ntwl <- twilightAdjust(twl, 300)\n\nlightImage(d.lux, offset = offset, zlim = c(0, 12))\ntsimagePoints(twl$Twilight, offset = offset, pch = 16, cex = 0.6,\n               col = ifelse(twl$Rise, \"dodgerblue\", \"firebrick\"))\n```\n\n## Calibration\n\n```{r}\n### get zenith anfle and alpha parameters\ntwl_calib <- subset(twl, (Twilight>=d.calib.tm[1] & Twilight<=d.calib.tm[2]))\n\nsun  <- solar(twl_calib[,1])\nz    <- refracted(zenith(sun, lon.calib, lat.calib))\n\ntwl_t   <- twilight(twl_calib[,1], lon.calib, lat.calib, rise = twl_calib[,2], zenith = max(z)+0.01)\ntwl_dev <- ifelse(twl_calib$Rise, as.numeric(difftime(twl_calib[,1], twl_t, units = \"mins\")),\n                  as.numeric(difftime(twl_t, twl_calib[,1], units = \"mins\")))\n\nhist(twl_dev[!twl_calib$Rise], freq = F, ylim = c(0, 0.065), \n     main = \"Stonechat 782 twilight error\", xlab = \"Twilight error (min)\")\nseq <- seq(0, 80, length = 100)\nfitml_ng <- fitdistr(twl_dev[!twl_calib$Rise], \"log-Normal\")\nlines(seq, dlnorm(seq, fitml_ng$estimate[1], fitml_ng$estimate[2]), \n      col = \"firebrick\", lwd = 3, lty = 2)\n```\n\n## Simple threshold estimates\n\n```{r, fig.height=10, fig.width=6}\n## cut out deployment site\ntwl <- subset(twl, Twilight>=(d.track.tm[1]-(4*24*60*60)))\n\nzenith0 <- median(z)\ntol <- 0.1\n\npath <- thresholdPath(twl$Twilight, twl$Rise, zenith = zenith0, tol = tol)\n\nopar <- par(mfrow = c(3, 1), mar = c(2,4,1,1)+0.1)\nplot(path$time, path$x[, 1], type = \"b\", pch = 16, cex = 0.5, ylab = \"Lon\", xlab = '')\nabline(h = lon.calib)\nplot(path$time, path$x[, 2], type = \"b\", pch = 16, cex = 0.5, ylab = \"Lat\", xlab = '')\nabline(h = lat.calib)\n\nplot(path$x, type = \"n\")\nplot(wrld_simpl, add = T, col = \"grey95\")\nbox()\nlines(path$x, col = \"blue\")\npoints(path$x, pch = 16, cex = 0.5, col = \"blue\")\npar(opar)\n```\n\n\n```{r}\ntFirst  <- twl[twl$Deleted==F,1][-nrow(twl[twl$Deleted==F,])]  #twl[-nrow(twl),1]\ntSecond <- twl[twl$Deleted==F,1][-1]  #twl[-1, 1]\ntype <- ifelse(twl[twl$Deleted==F,2], 1, 2)[-nrow(twl[twl$Deleted==F,])]\n\ntwl_gl <- data.frame(tFirst = tFirst, tSecond = tSecond, type = type)\n\ncL <- changeLight(twl_gl, quantile = 0.75, days = 1)\nsites <- cL$site\n```\n\n\n## Masks\n\nHere, we can use a spatial probability mask with high and equal probability on land and lower probability at the ocean; decreasing probability with increasing distance to the coastline. The lowest probability for locations (far from land) will have a 5 times lower probabaility than locations at land.\n\n```{r}\n## defining the boundaries\nxlim = c(100,150)\nylim = c(0, 65)\n\n## empty raster\nr <- raster(extent(xlim[1], xlim[2], ylim[1], ylim[2]), resolution = 0.15)\n\nwrld <- rasterize(wrld_simpl, r)\n  wrld[] <- ifelse(wrld[]>1, 1, NA)\n# plot(wrld)\n\nd.mask <- distance(wrld)\n# plot(d.mask)\n\n## Change according to your preferences (propability - distance to coastline relationship)\nsX <- seq(0, max(d.mask[], na.rm = T), by = 200) \nsY <- 1 + 5*exp(-((sX)/200000)^1)\n# plot(sX, sY)\n \nprob <- approxfun(x=sX, y=sY)\n \nprob.mask <- d.mask\nprob.mask[] <- prob(d.mask[])\n \n# plot(prob.mask)\n# plot(wrld_simpl, add = T)\n\nlookup <- function(r, xlim, ylim) {\n  r <- as.matrix(r)[nrow(r):1,]\n  \n  xbin <- seq(xlim[1], xlim[2], length = ncol(r) + 1)\n  ybin <- seq(ylim[1], ylim[2], length = nrow(r) + 1)\n  \n  function(p) {\n    r[cbind(.bincode(p[, 2], ybin), .bincode(p[, 1], xbin))]\n  }\n}\n\nprob <- lookup(prob.mask, xlim = xlim, ylim = ylim)\n\nlog.prior <- function(p) {\n  f <- prob(p)\n  ifelse(is.na(f), -1000, log(f))\n}\n```\n\n## Model parameters\n\nTwo states:\n*Movement\n*Residency\n\n```{r}\nbeta0 <- matrix(c(1, 0.2, 9, 0.25), 2, 2, byrow = T)\nmatplot(0:80, cbind(dgamma(0:80, beta0[1, 1], beta0[1, 2]), \n                    dgamma(0:80, beta0[2, 1], beta0[2, 2])), \n                    type = \"l\", col = c(\"red\",\"blue\"), lty = 1, lwd = 2, ylab = \"\")\n\nbeta <- matrix(c(ifelse(cL$site==0, beta0[2,1], beta0[1,1]),\n                 ifelse(cL$site==0, beta0[2,2], beta0[1,2])), ncol = 2)\n\nalpha =  c(fitml_ng$estimate[1], fitml_ng$estimate[2])\n```\n\n## Estelle simulation\n\n```{r}\npath <- thresholdPath(twl$Twilight, twl$Rise, zenith = zenith0, tol = tol)\nx0 <- path$x\n\nx0[1:3,1] <- lon.calib\nx0[1:3,2] <- lat.calib\n\nfixedx <- c(rep(TRUE, 3), rep(FALSE, nrow(twl)-3))\n\n## Intermediate track\nz0 <- trackMidpts(x0)\n\n\nmodel <- thresholdModel(twl$Twilight,twl$Rise,\n                        twilight.model=\"ModifiedLogNormal\",\n                        alpha=alpha,beta=beta,\n                        x0=x0,z0=z0,zenith=quantile(z, probs = 0.90),fixedx=fixedx)\n\nproposal.x <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(x0))\nproposal.z <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(z0))\n\nfit <- estelleMetropolis(model,proposal.x,proposal.z,iters=250,thin=20,chains=1)\n\nplot(wrld_simpl,col= \"grey90\", border=\"grey10\", xlim = range(x0[,1]), ylim = range(x0[,2]))\nxm <- locationMean(fit$x)\nlines(xm,col=rgb(t(col2rgb(\"cornflowerblue\"))/255,alpha=0.9))\npoints(xm,pch=16,cex=0.8,col=rgb(t(col2rgb(\"cornflowerblue\"))/255,alpha=0.5))\nbox()\n\n\nx0 <- chainLast(fit$x)\nz0 <- chainLast(fit$z)\n\nmodel <- thresholdModel(twl$Twilight,twl$Rise,\n                        twilight.model=\"LogNormal\",\n                        alpha=alpha,beta=beta,\n                        logp.x=log.prior,logp.z=log.prior,\n                        x0=x0,z0=z0,zenith=quantile(z, probs = 0.90),fixedx=fixedx)\nproposal.x <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(x0))\nproposal.z <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(z0))\n\n\nfit <- estelleMetropolis(model,proposal.x,proposal.z,\n                         iters=300,thin=20,chains=1)\nfor(k in 1:3) {\n  proposal.x <- mvnorm(chainCov(fit$x),s=0.2)\n  proposal.z <- mvnorm(chainCov(fit$z),s=0.2)\n  fit <- estelleMetropolis(model,proposal.x,proposal.z,\n                           x0=chainLast(fit$x),\n                           z0=chainLast(fit$z),\n                           iters=300,thin=20,chains=2)\n}\n\n\nproposal.x <- mvnorm(chainCov(fit$x),s=0.25)\nproposal.z <- mvnorm(chainCov(fit$z),s=0.25)\nfit <- estelleMetropolis(model,proposal.x,proposal.z,\n                         x0=chainLast(fit$x),\n                         z0=chainLast(fit$z),\n                         iters=2000,thin=20,chains=2)\n```\n\nCheck chain convergence:\n\n\n```{r}\ns <- locationSummary(fit$z,time=model$time,collapse=F)\n\n\nplot(wrld_simpl,xlim=xlim,ylim=ylim,col = \"grey90\",border = \"grey10\")\nplot(elide(wrld_simpl,shift=c(360,0)),xlim=xlim,ylim=ylim,add=T, col = \"grey90\",border = \"grey10\")\n\nfor(k in 1:length(s)) {\n  lines(s[[k]][,\"Lon.mean\"],s[[k]][,\"Lat.mean\"],\n        col=rgb(t(col2rgb(c(\"#E41A1C\", \"#377EB8\")[k]))/255,alpha=0.4))\n}\nbox()\n```\n\n## Movement vs. Residency analysis\n\nThe idea is to backtransform the estimated locations from the most likely path (z positions) into twilight times (e.g. sunrise and sunset). Than we can use the functionalities of `GeoLight` to distinguish between periods of residency and movement.  \n\n```{r}\nzm <- locationSummary(fit$z,time=model$time,collapse=T)\n\ntwl.back <- data.frame(Twilight = twilight(twl$Twilight[-nrow(twl)], zm$`Lon.50%`, zm$`Lat.50%`, \n                                           twl$Rise[-nrow(twl)], zenith=zenith0, iters = 5), \n                       Rise = twl$Rise[-nrow(twl)])\n\nlightImage(d.lux,offset=offset, zlim = c(0,12))\ntsimagePoints(twl.back$Twilight,offset=offset,pch=16,cex=0.8,\n               col=ifelse(twl.back$Rise,\"dodgerblue\",\"firebrick\"))\n```\n\n\n```{r}\ntwl.gl <- data.frame(tFirst = twl.back[-nrow(twl.back),1],\n                     tSecond = twl.back[-1, 1],\n                     type = ifelse(twl.back[,2], 1, 2)[-nrow(twl.back)])\n\nfixed <- matrix(FALSE, ncol = 2, nrow = nrow(twl.gl))\n  fixed[1:8,] <- cbind(TRUE, TRUE) # the points falling into the vicinity of the breeding site\n```\n\n### `changeLight` analysis\n\n```{r}\ncL <- changeLight(twl.gl, quantile = 0.9, days = 2, fixed = fixed, summary = T)\n```\n\n### `mergeChains` analysis\n\n```{r}  \nmS <- mergeSites(twl.gl, site = cL$site, fixed = fixed, distThreshold = 250, degElevation = 90-zenith0)\n```\n\n\n### Plot the results\n\n```{r}\nsiteMap(cbind(zm$`Lon.50%`, zm$`Lat.50%`), site = mS$site, xlim = xlim, ylim = ylim, type = 'cross', hull = F)\n\nschedule(twl.gl[,1], twl.gl[,2], site = mS$site)\n```\n\n## Compile output and save results\n\n\n",
    "created" : 1444953700235.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2609920843",
    "id" : "8DEB9128",
    "lastKnownWriteTime" : 1444969081,
    "path" : "C:/Users/slisovsk/Dropbox/Science/Projects/Stonechat/Workflow_782.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}