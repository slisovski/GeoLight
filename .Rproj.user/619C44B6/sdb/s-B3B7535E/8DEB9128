{
    "contents" : "---\ntitle: \"Stonechat - Geolocator Processing\"\nauthor: \"Simeon Lisovski\"\ndate: \"14 October 2015\"\noutput: html_document\n---\n\nLoad required packages:\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(GeoLight) ## Version 2.0\nlibrary(SGAT)\nlibrary(BAStag)\n\nlibrary(MASS)\nlibrary(maptools)\n  data(wrld_simpl)\n\n## the SGAT and BAStag package can be installed by:\n## library(devtools)\n## install_github(\"SWotherspoon/SGAT\")\n## install_github(\"SWotherspoon/BAStag\")\n```\n\nSet working directory:\n\n```{r}\nwd <- \"C:/Users/Simeon/Desktop/Stonechat\"\n```\n\nRead in and visualise raw data:\n\n```{r}\nd.lux <-  read.table(paste(wd, \"code and data/data/782.lux\", sep=\"/\"), \n                     header = FALSE, skip = 25, \n                     col.names = c(\"Date\",\"Time\", \"Light\"), \n                     colClasses = c(\"character\", \"character\", \"numeric\"))\nd.lux$Date <- as.POSIXct(strptime(paste(d.lux$Date, d.lux$Time), \n                                  \"%d/%m/%Y %H:%M:%S\", tz = \"GMT\"))\nd.lux$Light <- log(d.lux$Light)\n\n\noffset <- 4\nlightImage(d.lux, offset = offset, zlim = c(0, 12))\n\nlon.calib <- 141.4\t\nlat.calib <- 43.1\n\n## Ploting the twilight curves for the calibration site\ntm <- seq(d.lux[1,1], d.lux[nrow(d.lux),1], by = \"day\")\nrise <- rep(c(TRUE, FALSE), length(tm))\n\nc.dat <- data.frame(Twilight = twilight(rep(tm, each = 2), \n                                        lon = lon.calib, lat = lat.calib, \n                                        rise = rise, zenith = 96), Rise = rise)\n\ntsimagePoints(c.dat$Twilight, offset = offset, pch = 16, cex = 0.5,\n               col = ifelse(c.dat$Rise, \"dodgerblue\", \"firebrick\"))\n```\n\nDefine tracking and calibration boundary and twilight times:\n\n```{r}\n## Tracking period (only to be applied at the final run)\n# d.track.tm <- as.POSIXct(locator(n = 2)$x, origin = \"1970-01-01\", tz = \"GMT\")\nd.track.tm <- as.POSIXct(c(\"2014-10-09\", \"2015-01-25\"), tz = \"GMT\")\nabline(v = d.track.tm, col = \"green\")\n\n## Calibration period\n# d.calib.tm  <- as.POSIXct(locator(n = 2)$x, origin = \"1970-01-01\", tz = \"GMT\")\nd.calib.tm <- as.POSIXct(c(\"2014-05-11\", \"2014-09-28\"), tz = \"GMT\")\nd.calib <- subset(d.lux, (Date>=d.calib.tm[1] & Date<=d.calib.tm[2]))\n\nthreshold <- 0.5\n# twl <- preprocessLight(d.lux, threshold, offset = offset, lmax = 12)\n# dir.create(paste(wd, \"/AnalysisOutput/782\",sep=''))\n# write.csv(twl, paste(wd, \"/AnalysisOutput/782/782_twl.csv\", sep=\"/\"), row.names = FALSE)\n\ntwl <- read.csv(paste(wd, \"/AnalysisOutput/782/782_twl.csv\", sep=\"\"))\ntwl[,1] <- as.POSIXct(twl[,1], tz = \"GMT\")\ntwl <- twilightAdjust(twl, 300)\n```\n\n## Calibration\n\n```{r}\n### get zenith anfle and alpha parameters\ntwl_calib <- subset(twl, (Twilight>=d.calib.tm[1] & Twilight<=d.calib.tm[2]))\n\nsun  <- solar(twl_calib[,1])\nz    <- refracted(zenith(sun, lon.calib, lat.calib))\n\ntwl_t   <- twilight(twl_calib[,1], lon.calib, lat.calib, rise = twl_calib[,2], zenith = max(z)+0.3)\ntwl_dev <- ifelse(twl_calib$Rise, as.numeric(difftime(twl_calib[,1], twl_t, units = \"mins\")),\n                  as.numeric(difftime(twl_t, twl_calib[,1], units = \"mins\")))\n\nhist(twl_dev[!twl_calib$Rise], freq = F, ylim = c(0, 0.065), \n     main = \"Stonechat 782 twilight error\")\nseq <- seq(0, 80, length = 100)\nfitml_ng <- fitdistr(twl_dev[!twl_calib$Rise], \"log-Normal\")\nlines(seq, dlnorm(seq, fitml_ng$estimate[1], fitml_ng$estimate[2]), \n      col = \"firebrick\", lwd = 3, lty = 2)\n```\n\n## Simple threshold estimates\n\n```{r}\n## cut out deployment site\ntwl <- subset(twl, Twilight>=(d.track.tm[1]-(4*24*60*60)))\n\nzenith0 <- median(z)\ntol <- 0.1\n\npath <- thresholdPath(twl$Twilight, twl$Rise, zenith = zenith0, tol = tol)\n\n\nopar <- par(mfrow = c(2, 1), mar = c(2,4,1,1)+0.1)\nplot(path$time, path$x[, 1], type = \"b\", pch = 16, cex = 0.5, ylab = \"Lon\", xlab = '')\nabline(h = lon.calib)\nplot(path$time, path$x[, 2], type = \"b\", pch = 16, cex = 0.5, ylab = \"Lat\", xlab = '')\nabline(h = lat.calib)\npar(opar)\n\n\nplot(path$x, type = \"n\")\nplot(wrld_simpl, add = T, col = \"grey95\")\nbox()\nlines(path$x, col = \"blue\")\npoints(path$x, pch = 16, cex = 0.5, col = \"blue\")\n```\n\n\n```{r}\ntFirst  <- twl[twl$Deleted==F,1][-nrow(twl[twl$Deleted==F,])]  #twl[-nrow(twl),1]\ntSecond <- twl[twl$Deleted==F,1][-1]  #twl[-1, 1]\ntype <- ifelse(twl[twl$Deleted==F,2], 1, 2)[-nrow(twl[twl$Deleted==F,])]\n\ntwl_gl <- data.frame(tFirst = tFirst, tSecond = tSecond, type = type)\n\ncL <- changeLight(twl_gl, quantile = 0.70, days = 1)\nsites <- cL$site\n```\n\n\n## Masks\n\nHere, we can use a spatial probability mask with high and equal probability on land and lower probability at the ocean; decreasing probability with increasing distance to the coastline. The lowest probability for locations (far from land) will have a 5 times lower probabaility than locations at land.\n\n```{r}\n## defining the boundaries\nxlim = c(100,150)\nylim = c(0, 65)\n\n## empty raster\nr <- raster(extent(xlim[1], xlim[2], ylim[1], ylim[2]), resolution = 0.15)\n\nwrld <- rasterize(wrld_simpl, r)\n  wrld[] <- ifelse(wrld[]>1, 1, NA)\n# plot(wrld)\n\nd.mask <- distance(wrld)\n# plot(d.mask)\n\n## Change according to your preferences (propability - distance to coastline relationship)\nsX <- seq(0, max(d.mask[], na.rm = T), by = 200) \nsY <- 1 + 5*exp(-((sX)/200000)^1)\nplot(sX, sY)\n \nprob <- approxfun(x=sX, y=sY)\n \nprob.mask <- d.mask\nprob.mask[] <- prob(d.mask[])\n \nplot(prob.mask)\nplot(wrld_simpl, add = T)\n\nlookup <- function(r, xlim, ylim) {\n  r <- as.matrix(r)[nrow(r):1,]\n  \n  xbin <- seq(xlim[1], xlim[2], length = ncol(r) + 1)\n  ybin <- seq(ylim[1], ylim[2], length = nrow(r) + 1)\n  \n  function(p) {\n    r[cbind(.bincode(p[, 2], ybin), .bincode(p[, 1], xbin))]\n  }\n}\n\nprob <- lookup(prob.mask, xlim = xlim, ylim = ylim)\n\nlog.prior <- function(p) {\n  f <- prob(p)\n  ifelse(is.na(f), -1000, log(f))\n}\n```\n\n## Model parameters\n\nTwo states:\n*Movement\n*Residency\n\n```{r}\nbeta0 <- matrix(c(0.9, 3, 12, 0.3), 2, 2, byrow = T)\nmatplot(0:80, cbind(dgamma(0:80, beta0[1, 1], beta0[1, 2]), \n                   dgamma(0:80, beta0[2, 1], beta0[2, 2])), \n                   type = \"l\", col = c(\"red\",\"blue\"), lty = 1, lwd = 2, ylab = \"\")\n\nbeta <- matrix(c(ifelse(cL$site==0, beta[2,1], beta[1,1]),\n                 ifelse(cL$site==0, beta[2,2], beta[1,2])), ncol = 2)\n\nalpha =  c(fitml_ng$estimate[1], fitml_ng$estimate[2])\n```\n\n## Estelle simulation\n\n```{r}\npath <- thresholdPath(twl$Twilight, twl$Rise, zenith = zenith0, tol = tol)\nx0 <- path$x\n\nx0[1:3,1] <- lon.calib\nx0[1:3,2] <- lat.calib\n\nfixedx <- c(rep(TRUE, 3), rep(FALSE, nrow(twl)-3))\n\n## Intermediate track\nz0 <- trackMidpts(x0)\n\n\nmodel <- thresholdModel(twl$Twilight,twl$Rise,\n                        twilight.model=\"ModifiedLogNormal\",\n                        alpha=alpha,beta=beta,\n                        x0=x0,z0=z0,zenith=quantile(z, probs = 0.975),fixedx=fixedx)\n\nproposal.x <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(x0))\nproposal.z <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(z0))\n\nfit <- estelleMetropolis(model,proposal.x,proposal.z,iters=250,thin=20,chains=1)\n\nplot(wrld_simpl,col= \"grey90\", border=\"grey10\", xlim = range(x0[,1]), ylim = range(x0[,2]))\nxm <- locationMean(fit$x)\nlines(xm,col=rgb(t(col2rgb(\"cornflowerblue\"))/255,alpha=0.9))\npoints(xm,pch=16,cex=0.8,col=rgb(t(col2rgb(\"cornflowerblue\"))/255,alpha=0.5))\nbox()\n\n\nx0 <- chainLast(fit$x)\nz0 <- chainLast(fit$z)\n\nmodel <- thresholdModel(twl$Twilight,twl$Rise,\n                        twilight.model=\"LogNormal\",\n                        alpha=alpha,beta=beta,\n                        logp.x=log.prior,logp.z=log.prior,\n                        x0=x0,z0=z0,zenith=quantile(z, probs = 0.975),fixedx=fixedx)\nproposal.x <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(x0))\nproposal.z <- mvnorm(S=diag(c(0.005,0.005)),n=nlocation(z0))\n\n\nfit <- estelleMetropolis(model,proposal.x,proposal.z,\n                         iters=300,thin=20,chains=2)\nfor(k in 1:3) {\n  proposal.x <- mvnorm(chainCov(fit$x),s=0.2)\n  proposal.z <- mvnorm(chainCov(fit$z),s=0.2)\n  fit <- estelleMetropolis(model,proposal.x,proposal.z,\n                           x0=chainLast(fit$x),\n                           z0=chainLast(fit$z),\n                           iters=300,thin=20,chains=2)\n}\n\n\nproposal.x <- mvnorm(chainCov(fit$x),s=0.25)\nproposal.z <- mvnorm(chainCov(fit$z),s=0.25)\nfit <- estelleMetropolis(model,proposal.x,proposal.z,\n                         x0=chainLast(fit$x),\n                         z0=chainLast(fit$z),\n                         iters=2000,thin=20,chains=2)\n```\n\n\n## Movement vs. Residency analysis\n\n```{r}\nsr.col <- \"#FF7F00\"\nss.col <- \"#377EB8\"\nmn.col <- \"firebrick1\"\nci.col <- \"dodgerblue1\"\nasm.col <- \"grey70\"\ntrk.col <- \"steelblue\"\nmap1.col <- \"honeydew3\"\nmap2.col <- \"honeydew4\"\ngrp.pal <- c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\")\n\n\n\ns <- locationSummary(fit$z,time=model$time,collapse=F)\n\n\nplot(wrld_simpl,xlim=xlim,ylim=ylim,col = \"grey90\",border = \"grey10\")\nplot(elide(wrld_simpl,shift=c(360,0)),xlim=xlim,ylim=ylim,add=T, col = \"grey90\",border = \"grey10\")\n\nfor(k in 1:length(s)) {\n  lines(s[[k]][,\"Lon.mean\"],s[[k]][,\"Lat.mean\"],\n        col=rgb(t(col2rgb(grp.pal[k]))/255,alpha=0.4))\n}\nbox()\n```\n\n\n\n```{r}\ntwl.back <- data.frame(Twilight = twilight(twl$Twilight,xm[,1],xm[,2], twl$Rise, zenith=zenith0),\n                       Rise = twl$Rise)\n\nlightImage(d.lux,offset=offset, zlim = c(0,12))\ntsimagePoints(twl.back$Twilight,offset=offset,pch=16,cex=0.8,\n               col=ifelse(twl.back$Rise,\"dodgerblue\",\"firebrick\"))\n\ntFirst  <- twl.back[-nrow(twl.back),1]\ntSecond <- twl.back[-1, 1]\ntype <- ifelse(twl.back[,2], 1, 2)[-nrow(twl.back)]\n\ncL <- changeLight(tFirst = tFirst, tSecond = tSecond, type = type, \n                  quantile = 0.95, days = 2, summary = T)\n\nsiteMap(xm, site = cL$site, xlim = xlim, ylim = ylim)\n\n\n",
    "created" : 1444953700235.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "130834850",
    "id" : "8DEB9128",
    "lastKnownWriteTime" : 1444813470,
    "path" : "C:/Users/slisovsk/Dropbox/Science/Projects/Stonechat/Workflow_782.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}