lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik", "twl"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms)
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
plot(as.numeric(format(twl$Twilight0, "%H")) + as.numeric(format(twl$Twilight0, "%M"))/60 + as.numeric(format(twl$Twilight0, "%S"))/60/60,
ylim = c(-1, 15), pch = 16, cex = 0.5, col = ifelse(twl$Rise, "red", "blue"))
points(as.numeric(format(twl$Twilight, "%H")) + as.numeric(format(twl$Twilight, "%M"))/60 + as.numeric(format(twl$Twilight, "%S"))/60/60,
pch = "x", col = ifelse(twl$Rise, "red", "blue"))
plot(as.numeric(format(twl$Twilight0, "%H")) + as.numeric(format(twl$Twilight0, "%M"))/60 + as.numeric(format(twl$Twilight0, "%S"))/60/60,
ylim = c(-1, 15), pch = 16, cex = 0.5, col = ifelse(twl$Rise, "red", "blue"))
points(as.numeric(format(twl$Twilight, "%H")) + as.numeric(format(twl$Twilight, "%M"))/60 + as.numeric(format(twl$Twilight, "%S"))/60/60,
pch = "x", col = ifelse(twl$Rise, "red", "blue"), cex = 0.25)
points(as.numeric(format(twl$Twilight, "%H")) + as.numeric(format(twl$Twilight, "%M"))/60 + as.numeric(format(twl$Twilight, "%S"))/60/60,
pch = "x", col = ifelse(twl$Rise, "red", "blue"), cex = 0.5)
out_ML
crds
crds  <- cbind(145.9, -41.6)
tm    <- seq(as.POSIXct("2014-01-15", tz = "GMT"), as.POSIXct("2014-03-19", tz = "GMT"), by = "day")
srise <- twilight(tm, crds[1], crds[2], rise = T, zenith = 96, iters = 6)
sset  <- twilight(tm, crds[1], crds[2], rise = F, zenith = 96, iters = 6)
twl <- data.frame(Twilight0 = as.POSIXct(c(srise, sset), origin = "1970-01-01", tz = "GMT"),
Rise      = c(rep(TRUE, length(srise)), rep(FALSE, length(sset))))
twl <- twl[order(twl$Twilight0),]
twl$Twilight <- twl$Twilight0 + ifelse(twl$Rise, rgamma(sum(twl$Rise), 3.3, 0.8), -rgamma(sum(twl$Rise), 3.3, 0.8))*60
hist(c(as.numeric(twl$Twilight-twl$Twilight0)[twl$Rise],
as.numeric(twl$Twilight0-twl$Twilight)[!twl$Rise])/60, freq = F, breaks = seq(0, 20, by = 0.5), xlab = "Twilight error (mins)", main = "")
lines(seq(0.1, 20, length = 50), dgamma(seq(0.1, 20, length = 50), 3.3, 0.8), lwd = 2, col = rgb(0,0,1, alpha = 0.8), lty = 2)
### Transform data to fullfill GeoLight formating requirements:
twl.gl <- data.frame(tFirst = twl[-nrow(twl),1], tSecond = twl[-1,1])
if(twl$Rise[1]) {
twl.gl$type <- rep(c(1,2), nrow(twl.gl))[1:nrow(twl.gl)]
} else {
twl.gl$type <- rep(c(2,1), nrow(twl.gl))[1:nrow(twl.gl)]
}
# siteEstimate <- function(tFirst, tSecond, type, twl,
#                          degElevation,
#                          method = "gamma", parms = c(3.3, 0.8),
#                          xlim = c(-180, 180),
#                          ylim = c(-90, 90), res = c(0.5, 0.5)) {
# tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])
# tw <- data.frame(Twilight = .POSIXct(c(tab$tFirst, tab$tSecond), "GMT"),
#                 Rise = c(ifelse(tab$type==1, TRUE, FALSE), ifelse(tab$type == 1, FALSE, TRUE)))
# tw <- tw[!duplicated(tw$datetime),]
# tw <- tw[order(tw[,1]),]
loglik <- function(crds, degElevation, method, parms) {
t.tw <- twilight(twl$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(twl$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(twl$Twilight[twl$Rise], t.tw[twl$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!twl$Rise], twl$Twilight[!twl$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik", "twl"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms)
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
tm    <- seq(as.POSIXct("2014-01-15", tz = "GMT"), as.POSIXct("2014-05-19", tz = "GMT"), by = "day")
crds  <- cbind(145.9, -41.6)
tm    <- seq(as.POSIXct("2014-01-15", tz = "GMT"), as.POSIXct("2014-05-19", tz = "GMT"), by = "day")
srise <- twilight(tm, crds[1], crds[2], rise = T, zenith = 96, iters = 6)
sset  <- twilight(tm, crds[1], crds[2], rise = F, zenith = 96, iters = 6)
twl <- data.frame(Twilight0 = as.POSIXct(c(srise, sset), origin = "1970-01-01", tz = "GMT"),
Rise      = c(rep(TRUE, length(srise)), rep(FALSE, length(sset))))
twl <- twl[order(twl$Twilight0),]
twl$Twilight <- twl$Twilight0 + ifelse(twl$Rise, rgamma(sum(twl$Rise), 3.3, 0.8), -rgamma(sum(twl$Rise), 3.3, 0.8))*60
hist(c(as.numeric(twl$Twilight-twl$Twilight0)[twl$Rise],
as.numeric(twl$Twilight0-twl$Twilight)[!twl$Rise])/60, freq = F, breaks = seq(0, 20, by = 0.5), xlab = "Twilight error (mins)", main = "")
lines(seq(0.1, 20, length = 50), dgamma(seq(0.1, 20, length = 50), 3.3, 0.8), lwd = 2, col = rgb(0,0,1, alpha = 0.8), lty = 2)
loglik <- function(crds, degElevation, method, parms) {
t.tw <- twilight(twl$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(twl$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(twl$Twilight[twl$Rise], t.tw[twl$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!twl$Rise], twl$Twilight[!twl$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
twl
split
?split
which(format(twl$Twilight0, "%M/%D")%in%c("03/21", "09/21")))
which(format(twl$Twilight0, "%M/%D")%in%c("03/21", "09/21"))
format(twl$Twilight0, "%M/%D")
format(twl$Twilight0, "%m/%d")
which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
cut(which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21")))
which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21")))
which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
twl.sp
loglik <- function(crds, twl, degElevation, method, parms) {
t.tw <- twilight(twl$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(twl$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(twl$Twilight[twl$Rise], t.tw[twl$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!twl$Rise], twl$Twilight[!twl$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
twl.sp
loglik <- function(crds, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik", "twl.sp"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
i <- 1
nll <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
nll <- lapply(twl.sp, fun = function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
nll <- lapply(twl.sp, FUN = function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
j <- 1
loglik <- function(crds, x, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, x = twl.sp[[j]], degElevation = degElevation[i], method = method, parms = parms)
twl.sp[[j]]
loglik <- function(crds, x, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
loglik
twl.sp[[j]]
# tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
parallel::stopCluster(mycl)
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = twl.sp[[j]]$Twilight, Rise = twl.sp[[j]]$Rise, degElevation = degElevation[i], method = method, parms = parms)
nll
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
i
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
parallel::stopCluster(mycl)
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
str(nll)
do.call("cbind", nll)
apply(do.call("cbind", nll0), 1, function(x) if(any(is.infinite(x)), Inf, sum(x))
apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
nll0   <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
(max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
out_ML
any(!is.finite(out_A[,,i]))
out_A[,,i]
!is.finite(out_A[,,i])
!is.finite(out_A[,,i]))
is.finite(out_A[,,i])
any(!is.finite(abs(out_A[,,i])))
any(is.finite(abs(out_A[,,i])))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
nll
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
any(is.finite(abs(out_A[,,i])))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
points(out_ML[3,1], out_ML[3,2], pch = 21, bg = "white")
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
res = c(.5,.5)
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
# arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
# points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
plot(as.numeric(format(twl$Twilight0, "%H")) + as.numeric(format(twl$Twilight0, "%M"))/60 + as.numeric(format(twl$Twilight0, "%S"))/60/60,
ylim = c(-1, 15), pch = 16, cex = 0.5, col = ifelse(twl$Rise, "red", "blue"))
points(as.numeric(format(twl$Twilight, "%H")) + as.numeric(format(twl$Twilight, "%M"))/60 + as.numeric(format(twl$Twilight, "%S"))/60/60,
pch = "x", col = ifelse(twl$Rise, "red", "blue"), cex = 0.5)
degElevation = seq(-8, -4, by = 0.5)
degElevation
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,4], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,5], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
out_ML
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML))
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML)))
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
library(GeoLight)
siteEstimate()
siteEstimate
siteEstimate <- function(tFirst, tSecond, type, twl,
degElevation,
method = "gamma", parms = c(3.3, 0.8),
xlim = c(-180, 180),
ylim = c(-90, 90), res = c(0.5, 0.5)) {
tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])
tw <- data.frame(Twilight = .POSIXct(c(tab$tFirst, tab$tSecond), "GMT"),
Rise = c(ifelse(tab$type==1, TRUE, FALSE), ifelse(tab$type == 1, FALSE, TRUE)))
tw <- tw[!duplicated(tw$Twilight),]
tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(tw$Twilight, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(tw, f = ifelse(1:nrow(tw)<min(eq.ind), 1, ifelse(1:nrow(tw)>max(eq.ind), 2, NA)))
} else {
twl.sp <- list(tw)
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
list(SunElevation = degElevation,
Estimate = out_A,
mlLoc = out_ML)
}
library(GeoLight)
library(GeoLight)
