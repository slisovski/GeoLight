{
    "contents" : "#' @name GeoLight-package\n#' @aliases GeoLight\n#' @title The GeoLight Package\n#' @description This is a summary of all features of \\bold{\\code{GeoLight}}, a \\code{R}-package for \n#' analyzing light based geolocator data\n#' @details \\bold{\\code{GeoLight}} is a package to derive geographical positions from daily light intensity pattern. \n#' Positioning and calibration methods are based on the threshold-method (Ekstrom 2004, Lisovski \\emph{et al.} 2012). \n#' A changepoint model from the \\code{R} package \\code{changepoint} is implemented to distinguish between periods of \n#' residency and movement based on the sunrise and sunset times. Mapping functions are implemented \n#' using the \\code{R} package \\code{maps}.\n#' @section Getting Started: \n#' We refrain from giving detailed background on the (several steps of) \n#' analysis of light-based geolocator data here but strongly recommend the key-publications below. \n#' @section Updates:\n#' We advise all users to update their installation of \\bold{\\code{GeoLight}} regularly.\n#' Type \\code{news(package=\"GeoLight\")} to read news documentation about changes to the recent and all previous version of the package\n#' @section Important notes:\n#' Most functions in \\bold{\\code{GeoLight}} require the same initial units and mostly the format and object type is mandatory:\n#' \\tabular{rll}{\n#' \\tab \\code{tFirst} \\tab yyyy-mm-dd hh:mm \"UTC\" (see: \\code{\\link{as.POSIXct}}, \\link[=Sys.timezone]{time zones})\\cr\n#' \\tab \\code{tSecond} \\tab as \\emph{tFirst} (e.g. 2008-12-01 17:30) \\cr\n#' \\tab \\code{type} \\tab either 1 or 2 depending on wheter \\emph{tFirst} is sunrise (1) or sunset (2)\\cr\n#' \\tab \\code{coord} \\tab \\code{SpatialPoints} or a \\code{matrix}, containing x and y coordinates (in that order) \\cr\n#' \\tab \\code{degElevation} \\tab a \\code{vector} or a single \\code{value} of sun elevation angle(s) in degrees (e.g. -6)\n#' }\n#' @section FUNCTIONS AND DATASETS:\n#' In the following, we give a summary of the main functions and sample datasets in the \\bold{\\code{GeoLight}} package. \n#' Alternatively a list of all functions and datasets in alphabetical order is available by typing \\code{library(help=GeoLight)}. \n#' For further information on any of these functions, type \\code{help(function name)}.\n#'\n#'  @section CONTENTS:\n#' \\tabular{rll}{\n#' \\tab {I.} \\tab Determination of sunset and sunrise \\cr\n#' \\tab {II.} \\tab Residency analysis \\cr\n#' \\tab {III.} \\tab Calibration \\cr\n#' \\tab {IV.} \\tab {Positioning}\\cr\n#' \\tab {V.} \\tab {Data visualisation}\\cr\n#' \\tab {VI.} \\tab {Examples}\n#' }\n#' @section I. Determination of sunset and sunrise:\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{gleTrans}} \\tab transformation of already defined twilight events* \\cr\n#' \\tab \\code{\\link{glfTrans}} \\tab transformation of light intensity measurements over time* \\cr\n#' \\tab \\code{\\link{luxTrans}} \\tab transformation of light intensity measurements over time** \\cr\n#' \\tab \\code{\\link{lightFilter}} \\tab filter to remove noise in light intensity measurements during the night \\cr\n#' \\tab \\code{\\link{twilightCalc}} \\tab definition of twilight events (\\emph{sunrise, sunset}) from light intensity measurements \\cr\n#' }\n#' \n#' * written for data recorded by geolocator devices from the \\bold{Swiss Ornithological Institute} \\cr\n#' ** written for data recorded by geolocator devices from \\bold{Migrate Technology Ltd}\n#' \n#' @section II. Residency Analysis:\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{changeLight}} \\tab function to distinguish between residency and movement periods \\cr\n#' \\tab \\code{\\link{schedule}} \\tab function to produce a data frame summerizing the residency and movement pattern \\cr\n#' }\n#' \n#' @section III. Calibration:\n#' See Lisovski \\emph{et al.} 2012 for all implemented calibration methods.\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{getElevation}} \\tab function to calculate the sun elevation angle for data with known position \\cr\n#' \\tab \\code{\\link{HillEkstromCalib}} \\tab \\emph{Hill-Ekstrom calibration} for one or more defined stationary periods \\cr\n#' }\n#' \n#' @section IV. Positioning:\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{coord}} \\tab main function to derive a \\code{matrix} of spatial coordinates \\cr\n#' \\tab \\code{\\link{distanceFilter}} \\tab filter function to reduce unrealistic positions (not recommended, since the filtering ignore positioning error) \\cr\n#' \\tab \\code{\\link{loessFilter}} \\tab filter function to define outliers in sunrise and sunset times (defined twilight events) \\cr\n#' }\n#' \n#' @section V. Data visualisation:\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{tripMap}} \\tab function to map the derived positions and combine the coordinates in time order\\cr\n#' \\tab \\code{\\link{siteMap}} \\tab function to show the results of the residency analysis on a map \\cr\n#' }\n#' \n#' @section IV. Examples:\n#' \\tabular{rll}{\n#' \\tab \\code{\\link{calib1}} \\tab data for calibration: light intensities \\cr\n#' \\tab \\code{\\link{calib2}} \\tab  data for calibration: Calculated twilight events (from \\code{\\link{calib1}} by \\code{\\link{twilightCalc}}) \\cr\n#' \\tab \\code{\\link{hoopoe1}} \\tab light intensity measurements over time recorded on a migratory bird \\cr\n#' \\tab \\code{\\link{hoopoe2}} \\tab sunrise and sunset times: From light intensity measurement (from \\code{\\link{hoopoe1}}) \\cr\n#' }\n#' \n#' @section \\bold{\\code{R}} Packages for Further Spatial Ananlyses:\n#' \\code{spatstat} \\cr\n#' \\code{adehabitat} \\cr\n#' \\code{gstat} \\cr\n#' \\code{trip} \\cr\n#' \\code{tripEstimation} \\cr\n#' \\code{move} \\cr\n#' ...\n#' \n#' @section Acknowledgements:\n#' Steffen Hahn, Felix Liechti, Fraenzi Korner-Nievergelt, Andrea Koelzsch, Eldar Rakhimberdiev, Erich Baechler, Eli Bridge,  Andrew Parnell, Richard Inger\n#'\n#' @section Authors:\n#' Simeon Lisovski, Simon Wotherspoon, Michael Sumner, Silke Bauer, Tamara Emmenegger \\cr\n#' Maintainer: Simeon Lisovski <simeon.lisovski(at)gmail.com>\n#' \n#' @section References:\n#' Ekstrom, P.A. (2004) An advance in geolocation by light. \\emph{Memoirs of the National Institute of Polar Research}, Special Issue, \\bold{58}, 210-226.\n#' \n#' Fudickar, A.M., Wikelski, M., Partecke, J. (2011) Tracking migratory songbirds: accuracy of light-level loggers (geolocators) in forest habitats. \\emph{Methods in Ecology and Evolution}, DOI: 10.1111/j.2041-210X.2011.00136.x.\n#'\n#' Hill, C. & Braun, M.J. (2001) Geolocation by light level - the next step: Latitude. \\emph{Electronic Tagging and Tracking in Marine Fisheries} (eds J.R. Sibert & J. Nielsen), pp. 315-330. Kluwer Academic Publishers, The Netherlands.\n#'\n#' Hill, R.D. (1994) Theory of geolocation by light levels. \\emph{Elephant Seals: Population Ecology, Behavior, and Physiology} (eds L. Boeuf, J. Burney & R.M. Laws), pp. 228-237. University of California Press, Berkeley.\n#'  \n#' Lisovski, S. and Hahn, S. (2012) GeoLight - processing and analysing light-based geolocator data in R. \\emph{Methods in Ecology and Evolution}, doi: 10.1111/j.2041-210X.2012.00248.x\n#' \n#' Lisovski, S., Hewson, C.M, Klaassen, R.H.G., Korner-Nievergelt, F., Kristensen, M.W & Hahn, S. (2012) Geolocation by light: Accuracy and precision affected by environmental factors. \\emph{Methods in Ecology and Evolution}, doi: 10.1111/j.2041-210X.2012.00185.x\n#' \n#' Wilson, R.P., Ducamp, J.J., Rees, G., Culik, B.M. & Niekamp, K. (1992) Estimation of location: global coverage using light intensity. \\emph{Wildlife telemetry: remote monitoring and tracking of animals} (eds I.M. Priede & S.M. Swift), pp. 131-134. Ellis Horward, Chichester.\nNULL\n\n\ni.argCheck <- function(y) {\n  \n  if(any(sapply(y, function(x) class(x))==\"data.frame\")) {\n    ind01 <- which(sapply(y, function(x) class(x))==\"data.frame\")\n    if(!all(ind02 <- c(\"tFirst\", \"tSecond\", \"type\")%in%names(y[[ind01]]))) {\n      whc <- paste(\"The following columns in data frame twl are missing with no default: \", paste(c(\"tFirst\", \"tSecond\", \"type\")[!ind02], collapse = \" and \"), sep = \"\")\n      stop(whc , call. = F)\n    } \n    out <- y[[ind01]]\n  } else {\n    if(!all(c(\"tFirst\", \"tSecond\", \"type\")%in%names(y))) {\n      ind03 <- c(\"tFirst\", \"tSecond\", \"type\")%in%names(y)\n      stop(sprintf(paste(paste(c(\"tFirst\", \"tSecond\", \"type\")[!ind03], collapse = \" and \"), \"is missing with no default.\")))\n    } else {\n      out <- data.frame(tFirst = y$tFirst, tSecond = y$tSecond, type = y$type)\n    }\n  }\n  if(any(c(class(out[,1])[1], class(out[,2])[1])!=\"POSIXct\")) {\n    stop(sprintf(\"Date and time inforamtion (e.g. tFirst and tSecond) need to be provided as POSIXct class objects.\"), call. = F)\n  }\n  out  \n  \n}\n\n\n##' Estimate location from consecutive twilights\n##'\n##' This function estimates the location given the times at which \n##' the observer sees two successive twilights.\n##' \n##' Longitude is estimated by computing apparent time of local noon\n##' from sunrise and sunset, and determining the longitude for which\n##' this is noon. Latitude is estimated from the required zenith and\n##' the sun's hour angle for both sunrise and sunset, and averaged.\n##'\n##' When the solar declination is near zero (at the equinoxes)\n##' latitude estimates are extremely sensitive to errors.  Where the\n##' sine of the solar declination is less than \\code{tol}, the\n##' latitude estimates are returned as \\code{NA}.\n##' \n##' The format (date and time) of \\emph{tFirst} and \\emph{tSecond} has to be\n##' \"yyyy-mm-dd hh:mm\" corresponding to Universal Time Zone UTC (see:\n##' \\code{\\link{as.POSIXct}}, \\link[=Sys.timezone]{time zones})\n##' \n##' \n##' @title Simple Threshold Geolocation Estimates\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param degElevation the sun elevation angle (in degrees) that defines twilight (e.g. -6 for \"civil\n##' twilight\"). Either a single value, a \\code{vector} with the same length as\n##' \\code{tFirst} or \\code{nrow(x)}.\n##' @param tol tolerance on the sine of the solar declination (only implemented in method 'NOAA').\n##' @param note \\code{logical}, if TRUE a notation of how many positions could\n##' be calculated in proportion to the number of failures will be printed at the\n##' end.\n##' @param method Defines the method for the location estimates. 'NOAA' is based on\n##' code and the excel spreadsheet from the NOAA site (http://www.esrl.noaa.gov/gmd/grad/solcalc/),\n##' 'Montenbruck' is based on Montenbruck, O. & Pfleger, T. (2000) Astronomy on the Personal\n##' Computer. \\emph{Springer}, Berlin.\n##' @return A matrix of coordinates in decimal degrees. First column are\n##' longitudes, expressed in degrees east of Greenwich. Second column contains\n##' the latitudes in degrees north the equator.\n##' @author Simeon Lisovski, Simon Wotherspoon, Michael Sumner\n##' @examples\n##' data(hoopoe2)\n##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n##' crds <- coord(hoopoe2, degElevation=-6, tol = 0.2)\n##' ## tripMap(crds, xlim=c(-20,20), ylim=c(5,50), main=\"hoopoe2\")\n##' @export   \ncoord  <- function(tFirst, tSecond, type, twl, degElevation = -6, tol = 0, method = \"NOAA\",  note = TRUE) {\n  \n  tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])   \n  \n  rise <- ifelse(tab$type==1, tab$tFirst, tab$tSecond)\n  set <- ifelse(tab$type==1, tab$tSecond, tab$tFirst)\n  \n  if(method == \"NOAA\") {\n    rad <- pi/180\n    sr <- solar(rise)\n    ss <- solar(set)\n    cosz <- cos(rad*(90-degElevation))\n    lon <- -(sr$solarTime+ss$solarTime+ifelse(sr$solarTime<ss$solarTime,360,0))/2\n    lon <- (lon+180)%%360-180\n    \n    ## Compute latitude from sunrise\n    hourAngle <- sr$solarTime+lon-180\n    a <- sr$sinSolarDec\n    b <- sr$cosSolarDec*cos(rad*hourAngle)\n    x <- (a*cosz-sign(a)*b*suppressWarnings(sqrt(a^2+b^2-cosz^2)))/(a^2+b^2)\n    lat1 <- ifelse(abs(a)>tol,asin(x)/rad,NA)\n    \n    ## Compute latitude from sunset\n    hourAngle <- ss$solarTime+lon-180\n    a <- ss$sinSolarDec\n    b <- ss$cosSolarDec*cos(rad*hourAngle)\n    x <- (a*cosz-sign(a)*b*suppressWarnings(sqrt(a^2+b^2-cosz^2)))/(a^2+b^2)\n    lat2 <- ifelse(abs(a)>tol,asin(x)/rad,NA)\n    \n    ## Average latitudes\n    out <- cbind(lon=lon,lat=rowMeans(cbind(lat1,lat2),na.rm=TRUE))\n  } \n  \n  if(method == \"Montenbruck\") {\n    \n    out <- coord2(tab$tFirst, tab$tSecond, tab$type, degElevation)\n    \n  }\n  \n  \n  if(note) cat(paste(\"Note: Out of \", nrow(out),\" twilight pairs, the calculation of \", sum(is.na(out[,2])),\" latitudes failed \",\"(\",\n                     floor(sum(is.na(out[,2])*100)/nrow(out)),\" %)\",sep=\"\"))\n  out\n}\n\ncoord2 <- function(tFirst, tSecond, type, degElevation=-6) {\n  \n  # if noon, RadHourAngle = 0, if midnight RadHourAngle = pi\n  # --------------------------------------------------------\n  RadHourAngle <- numeric(length(type))\n  index1 <- type==1\n  if (sum(index1)>0) RadHourAngle[index1] <- 0\n  RadHourAngle[!index1] <- pi\n  # --------------------------------------------------------\n  \n  tSunTransit <- as.character(as.POSIXct(tFirst, tz = \"GMT\") + as.numeric(difftime(as.POSIXct(tSecond, tz = \"GMT\"), \n                                                                                   as.POSIXct(tFirst, tz = \"GMT\"), \n                                                                                   units=\"secs\")/2))\n  \n  index0 <- (nchar(tSunTransit) <= 10)\n  if(sum(index0)>0) tSunTransit[index0] <- as.character(paste(tSunTransit[index0],\" \",\"00:00\",sep=\"\"))\n  \n  # Longitude\n  jD  <- i.julianDate(as.numeric(substring(tSunTransit,1,4)),as.numeric(substring(tSunTransit,6,7)),\n                      as.numeric(substring(tSunTransit,9,10)),as.numeric(substring(tSunTransit,12,13)),as.numeric(substring(tSunTransit,15,16)))\n  jD0 <- i.julianDate(as.numeric(substring(tSunTransit,1,4)),as.numeric(substring(tSunTransit,6,7)),\n                      as.numeric(substring(tSunTransit,9,10)),rep(0,length(tFirst)),rep(0,length(tFirst)))\n  jC  <- i.JC2000(jD)\n  jC0 <- i.JC2000(jD0)\n  \n  radObliquity         <- i.radObliquity(jC)\n  radEclipticLongitude <- i.radEclipticLongitude(jC)\n  radRightAscension    <- i.radRightAscension(radEclipticLongitude,radObliquity)\n  radGMST              <- i.radGMST(jD,jD0,jC,jC0)\n  \n  degLongitude <- i.setToRange(-180,180,i.deg(RadHourAngle + radRightAscension - radGMST))\n  \n  \n  # Latitude\n  jD  <- i.julianDate(as.numeric(substring(tFirst,1,4)),as.numeric(substring(tFirst,6,7)),\n                      as.numeric(substring(tFirst,9,10)),as.numeric(substring(tFirst,12,13)),\n                      as.numeric(substring(tFirst,15,16)))\n  jD0 <- i.julianDate(as.numeric(substring(tFirst,1,4)),as.numeric(substring(tFirst,6,7)),\n                      as.numeric(substring(tFirst,9,10)),rep(0,length(tFirst)),rep(0,length(tSecond)))\n  jC  <- i.JC2000(jD)\n  jC0 <- i.JC2000(jD0)\n  \n  \n  radElevation         <- if(length(degElevation)==1) rep(i.rad(degElevation),length(jD)) else i.rad(degElevation)\n  \n  sinElevation         <- sin(radElevation)\n  radObliquity         <- i.radObliquity(jC)\n  radEclipticLongitude <- i.radEclipticLongitude(jC)\n  radDeclination       <- i.radDeclination(radEclipticLongitude,radObliquity)\n  sinDeclination       <- sin(radDeclination)\n  cosDeclination       <- cos(radDeclination)\n  \n  radHourAngle         <- i.radGMST(jD,jD0,jC,jC0) + i.rad(degLongitude) - i.radRightAscension(radEclipticLongitude,radObliquity)\n  cosHourAngle         <- cos(radHourAngle)\n  \n  term1                <- sinElevation/(sqrt(sinDeclination^2 + (cosDeclination*cosHourAngle)^2))\n  term2                <- (cosDeclination*cosHourAngle)/sinDeclination\n  \n  degLatitude <- numeric(length(radElevation))\n  \n  index1  <- (abs(radElevation) > abs(radDeclination))\n  if (sum(index1)>0) degLatitude[index1] <- NA\n  \n  index2  <- (radDeclination > 0 & !index1)\n  if (sum(index2)>0)  degLatitude[index2] <- i.setToRange(-90,90,i.deg(asin(term1[index2])-atan(term2[index2])))\n  \n  index3  <- (radDeclination < 0 & !index1)\n  if (sum(index3)>0)  degLatitude[index3] <- i.setToRange(-90,90,i.deg(acos(term1[index3])+atan(1/term2[index3])))\n  \n  degLatitude[!index1&!index2&!index3] <- NA\n  \n  cbind(degLongitude, degLatitude)\n}\n\n\n\n##' Function to calculate the median sun elevation angle for light measurements at a\n##' known location and the choosen light threshold.\n##' \n##' Optionally, shape and scale paramters of the twiligth error (in minutes) can be estimated. The error is assumed\n##' to follow a log-normal distribution and 0 (elev0) is set 0.1 below the minimum sun elevation angle of estimated twilight times.\n##' Those parameters might be of interest for sensitivity analysis or further processing using the R Package SGAT (https://github.com/SWotherspoon/SGAT).\n##'\n##' @title Calculate the appropriate sun elevation angle for known location\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param known.coord a \\code{SpatialPoint} or \\code{matrix} object, containing\n##' known x and y coordinates (in that order) for the selected measurement\n##' period.\n##' @param plot \\code{logical}, if TRUE a plot will be produced.\n##' @param lnorm.pars \\code{logical}, if TRUE shape and scale parameters of the twilight error (log-normal distribution) \n##' will be estimated and included in the output (see Details).\n##' @author Simeon Lisovski\n##' @references Lisovski, S., Hewson, C.M, Klaassen, R.H.G., Korner-Nievergelt,\n##' F., Kristensen, M.W & Hahn, S. (2012) Geolocation by light: Accuracy and\n##' precision affected by environmental factors. \\emph{Methods in Ecology and\n##' Evolution}, DOI: 10.1111/j.2041-210X.2012.00185.x.\n##' @examples\n##' data(calib2)\n##'   calib2$tFirst  <- as.POSIXct(calib2$tFirst, tz = \"GMT\")\n##'   calib2$tSecond <- as.POSIXct(calib2$tSecond, tz = \"GMT\")\n##' getElevation(calib2, known.coord = c(7.1,46.3), lnorm.pars = TRUE)\n##' @importFrom MASS fitdistr\n##' @importFrom graphics arrows par hist plot lines mtext\n##' @importFrom stats dlnorm median\n##' @export getElevation\ngetElevation <- function(tFirst, tSecond, type, twl, known.coord, plot=TRUE, lnorm.pars = FALSE) {\n  \n  tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])   \n  tab <- geolight.convert(tab[,1], tab[,2], tab[,3])  \n  \n  sun <- solar(as.POSIXct(tab[,1], \"GMT\"))\n  z   <- 90-refracted(zenith(sun, known.coord[1], known.coord[2]))\n  \n  tab$z.tm <- as.POSIXct(\"1900-01-01 00:00:01\", \"GMT\")\n  tab$z.tm[tab[,2]] <- twilight(tab[tab[,2], 1], known.coord[1], known.coord[2], rise = TRUE, zenith = (min(z)-0.1)-90 ,iters = 3) \n  tab$z.tm[!tab[,2]] <- twilight(tab[!tab[,2],1], known.coord[1], known.coord[2], rise = FALSE, zenith = (min(z)-0.1)-90 ,iters = 3)\n  \n  tab$diff <- NA \n  \n  tab$diff[tab[,2]] <- as.numeric(difftime(tab[tab[,2],1], tab[tab[,2],3], units = \"mins\"))\n  tab$diff[!tab[,2]] <- as.numeric(difftime(tab[!tab[,2],3], tab[!tab[,2],1], units = \"mins\"))\n  \n  \n  if(plot) {\n    opar <- par(mfrow = c(1, 2), mar = c(7, 7, 5, 1), oma = c(0, 0, 0, 2), \n                cex.lab = 1.5, cex.axis = 1.5, las = 1, mgp = c(4.8, 2, 1))\n    \n    hist(z, breaks =  seq(min(z)-0.5, max(z)+0.5, length = 18), main = \"\", \n         col = \"grey60\", xlab = \"Sun elevaion angle\")\n    arrows(median(z), -0.75, median(z), -0.1,  lwd = 3, col = \"cornflowerblue\", xpd = T)\n    mtext(paste(\"median elevation\", round(median(z),2)), font = 3, col = \"cornflowerblue\", cex = 1.2, line = 1.6)\n    \n    hist(tab$diff, freq = F, breaks = seq(min(tab$diff)-2, max(tab$diff)+2, length = 18), \n         main = \"\", xlab = \"Twilight error (minutes)\", col = \"grey95\", ylab = \"Probability density\")\n    \n    if(lnorm.pars) {\n      seq1 <- seq(0, max(tab$diff), length = 100)\n      fit <- fitdistr(tab$diff, \"log-Normal\")\n      lines(seq1, dlnorm(seq1, fit$estimate[1], fit$estimate[2]), col = \"firebrick\", lwd = 3, lty = 2)\n      \n      mtext(paste(\"elev0 =\", round((min(z)-0.1), 2), \"\\nshape =\", round(fit$estimate[1],2), \n                  \"\\nscale =\", round(fit$estimate[2],2)), \n            font = 3, col = \"firebrick\", cex = 1.2, line = 0.5)\n    }\n    par(opar)\n  }\n  \n  if(lnorm.pars) c(med.elev=median(z), shape = as.numeric(fit$estimate[1]), \n                   scale = as.numeric(fit$estimate[2])) else c(med.elev = median(z))\n}\n\n\n##' Residency analysis using a changepoint model\n##'\n##' Function to discriminate between periods of residency and movement based on\n##' consecutive sunrise and sunset data. The calculation is based on a\n##' changepoint model (\\bold{\\pkg{R}} Package \\code{\\link{changepoint}}:\n##' \\code{\\link{cpt.mean}}) to find multiple changepoints within the\n##' data.\n##'\n##' The \\code{cpt.mean} from the \\code{R} Package \\code{changepoint} is a\n##' function to find a multiple changes in mean for data where no assumption is\n##' made on their distribution. The value returned is the result of finding the\n##' optimal location of up to Q changepoints (in this case as many as possible)\n##' using the cumulative sums test statistic.\n##'\n##'\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param quantile probability threshold for stationary site selection. Higher\n##' values (above the defined quantile of all probabilities) will be considered\n##' as changes in the behavior. Argmuent will only be considered if either \\code{rise.prob} and/or\n##' \\code{set.prob} remain unspecified.\n##' @param rise.prob the probability threshold for \\bold{sunrise}: greater or\n##' equal values indicates changes in the behaviour of the individual.\n##' @param set.prob the probability threshold for \\bold{sunset}: higher and\n##' equal values indicates changes in the behaviour of the individual.\n##' @param days a threshold for the length of stationary period. Periods smaller\n##' than \"days\" will not be considered as a residency period\n##' @param fixed ...\n##' @param plot logical, if \\code{TRUE} a plot will be produced\n##' @param summary logical, if \\code{TRUE} a summary of the results will be\n##' printed\n##' @return A \\code{list} with probabilities for \\emph{sunrise} and\n##' \\emph{sunset} the user settings of the probabilities and the resulting\n##' stationary periods given as a \\code{vector}, with the residency sites as\n##' positiv numbers in ascending order (0 indicate movement/migration).\n##' @note The sunrise and/or sunset times shown in the graph (if\n##' \\code{plot=TRUE}) represent hours of the day. However if one or both of the\n##' twilight events cross midnight during the recording period the values will\n##' be formed to avoid discontinuity.\n##' @author Simeon Lisovski & Tamara Emmenegger\n##' @seealso \\code{\\link{changepoint}}, \\code{\\link{cpt.mean}}\n##' @references Taylor, Wayne A. (2000) Change-Point Analysis: A Powerful New\n##' Tool For Detecting Changes.\n##'\n##' M. Csorgo, L. Horvath (1997) Limit Theorems in Change-Point Analysis.\n##' \\emph{Wiley}.\n##'\n##' Chen, J. and Gupta, A. K. (2000) Parametric statistical change point\n##' analysis. \\emph{Birkhauser}.\n##' @examples\n##'\n##' data(hoopoe2)\n##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n##' residency <- changeLight(hoopoe2, quantile=0.9)\n##'\n##' @importFrom changepoint cpt.mean cpts.full pen.value.full\n##' @importFrom stats na.omit quantile\n##' @importFrom graphics abline axis layout mtext par plot rect\n##' @export changeLight\nchangeLight <- function (tFirst, tSecond, type, twl, quantile = 0.9, rise.prob = NA, \n                         set.prob = NA, days = 5, fixed = NULL, plot = TRUE, summary = TRUE) {\n  \n  tab <- GeoLight:::i.argCheck(as.list(environment())[sapply(environment(), \n                                                             FUN = function(x) any(class(x) != \"name\"))])\n  \n  if(is.null(fixed)) fixed <- matrix(FALSE, ncol = 2, nrow = nrow(tab))\n  \n  tw <- data.frame(datetime = .POSIXct(c(tab$tFirst, tab$tSecond), \"GMT\"), \n                   type = c(tab$type, ifelse(tab$type == 1, 2, 1)),\n                   fixed = c(fixed[,1], fixed[,2]))\n  tw <- tw[!duplicated(tw$datetime), ]\n  tw <- tw[order(tw[, 1]), ]\n  hours <- as.numeric(format(tw[, 1], \"%H\")) + as.numeric(format(tw[,1], \"%M\"))/60\n  \n  for (t in 1:2) {\n    cor <- rep(NA, 24)\n    for (i in 0:23) {\n      cor[i + 1] <- max(abs((c(hours[tw$type == t][1], \n                               hours[tw$type == t]) + i)%%24 - (c(hours[tw$type == t], \n                                                                  hours[tw$type == t][length(hours)]) + i)%%24), na.rm = T)\n    }\n    hours[tw$type == t] <- (hours[tw$type == t] + (which.min(round(cor, 2))) - 1)%%24\n  }\n  \n  sr <- tw[tw[, 2] == 1, 1]\n  ss <- tw[tw[, 2] == 2, 1]\n  rise <- hours[tw[, 2] == 1]\n  set <- hours[tw[, 2] == 2]\n  CPs1 <- suppressWarnings(changepoint:::cpt.mean(rise, method = \"BinSeg\", \n                                                  Q = length(rise)/2, penalty = \"Manual\", pen.value = 0.001, \n                                                  test.stat = \"CUSUM\", param.estimates = FALSE))\n  CPs2 <- suppressWarnings(changepoint:::cpt.mean(set, method = \"BinSeg\", \n                                                  Q = length(set)/2, penalty = \"Manual\", pen.value = 0.001, \n                                                  test.stat = \"CUSUM\", param.estimates = FALSE))\n  N1 <- seq(1, length(rise))\n  N2 <- seq(1, length(set))\n  tab1 <- merge(data.frame(N = N1, prob = NA), data.frame(N = changepoint:::cpts.full(CPs1)[nrow(changepoint:::cpts.full(CPs1)),], \n                                                          prob = changepoint:::pen.value.full(CPs1)/2), by.x = \"N\", by.y = \"N\", all.x = T)[, -2]\n  tab1[is.na(tab1[, 2]), 2] <- 0\n  tab1[tw$fixed[tw$type==1],2] <- NA\n  \n  tab2 <- merge(data.frame(N = N2, prob = NA), data.frame(N = changepoint:::cpts.full(CPs2)[nrow(changepoint:::cpts.full(CPs2)),], \n                                                          prob = changepoint:::pen.value.full(CPs2)/2), by.x = \"N\", by.y = \"N\",all.x = T)[, -2]\n  tab2[is.na(tab2[, 2]), 2] <- 0\n  tab2[tw$fixed[tw$type==2],2] <- NA\n  \n  if (is.na(rise.prob) & is.na(set.prob)) {\n    rise.prob <- as.numeric(round(as.numeric(quantile(tab1[tab1[, \n                                                                2] != 0, 2], probs = quantile, na.rm = TRUE)), digits = 5))\n    set.prob <- as.numeric(round(as.numeric(quantile(tab2[tab2[, \n                                                               2] != 0, 2], probs = quantile, na.rm = TRUE)), digits = 5))\n  }\n  riseProb <- ifelse(tab1[, 2] >= rise.prob, NA, TRUE)\n  setProb <- ifelse(tab2[, 2] >= set.prob, NA, TRUE)\n  tmp02 <- rbind(data.frame(time = tw[tw[, 2] == 1, 1], prob = tab1[,2], cut = riseProb, fixed = tw$fixed[tw[, 2] == 1]), \n                 data.frame(time = tw[tw[, 2] == 2, 1], prob = tab2[, 2], cut = setProb, fixed = tw$fixed[tw[, 2] == 2]))[order(c(sr, ss)), ]\n  tmp02 <- cbind(tmp02, NA)\n  \n  s <- 1\n  for (i in 1:nrow(tmp02)) {\n    if(i<nrow(tmp02)) if(tmp02$fixed[i+1] & !tmp02$fixed[i]) tmp02$cut[i] <- NA\n    if(i>1) if(tmp02$fixed[i-1] & !tmp02$fixed[i]) tmp02$cut[i] <- NA\n    \n    if(tmp02[i, 'fixed']) {\n      if(i>1) if(is.na(tmp02$cut[i-1]) & !tmp02$fixed[i-1]) s <- s+1\n      tmp02[i, 5] <- s} else { \n        if(i%in%c(2:(nrow(tmp02)-1))){\n          if(is.na(tmp02[i - 1, 'cut']) & !is.na(tmp02[i, 'cut'])) {\n            s <- s + 1\n            tmp02[i, 5] <- s\n          }\n          if (!is.na(tmp02[i - 1, 'cut']) & !is.na(tmp02[i, 'cut'])) \n            tmp02[i, 5] <- s\n        }\n      }\n  }\n  ind01 <- aggregate(as.numeric(tmp02[!is.na(tmp02[,5]) & !tmp02$fixed,1]), by = list(tmp02[!is.na(tmp02[,5]) & !tmp02$fixed, 5]), \n                     FUN =  function(x) (x[length(x)] - x[1])/60/60/24 > days)\n  tmp02[, 5] <- ifelse(tmp02[, 5]%in%c(ind01[ind01[,2],1], unique(tmp02[tmp02$fixed, 5])), tmp02[, 5], NA)\n  \n  s <- 1\n  for (i in unique(tmp02[!is.na(tmp02[,5]),5])) {\n    tmp02[!is.na(tmp02[, 5]) & tmp02[, 5] == i, 5] <- s\n    s <- s + 1\n  }\n  t02 <- schedule(tab$tFirst, tab$tSecond, tmp02[1:nrow(tab),5])\n  arr <- tmp02[!is.na(tmp02[, 5]) & !duplicated(tmp02[, 5]),]\n  dep <- tmp02[!is.na(tmp02[, 5]) & !duplicated(tmp02[, 5], fromLast = T), ]\n  t02$P.start <- arr$prob\n  t02$P.end <- dep$prob\n  t02$Days <- apply(t02, 1, function(x) round(as.numeric(difftime(x[3], x[2], units = \"days\")), 1))\n  ds <- t02\n  out <- list(riseProb = tab1[, 2], setProb = tab2[, 2], rise.prob = rise.prob, \n              set.prob = set.prob, site = ifelse(!is.na(tmp02[, 5]), \n                                                 tmp02[, 5], 0)[1:nrow(tab)], migTable = ds)\n  if (plot) {\n    def.par <- par(no.readonly = TRUE)\n    nf <- layout(matrix(c(4, 1, 2, 3), nrow = 4, byrow = T), \n                 heights = c(0.5, 1, 0.5, 0.5))\n    par(mar = c(2, 4.5, 2, 5), cex.lab = 1.5, cex.axis = 1.5, \n        bty = \"o\")\n    rise[tw$fixed[tw$type==1]] <- NA\n    plot(sr, rise, \n         type = \"o\", cex = 0.2, col = \"firebrick\", \n         ylab = \"Sunrise (red)\", xlim = range(sr), xaxt = \"n\")\n    par(new = T)\n    set[tw$fixed[tw$type==2]] <- NA\n    plot(ss, set, type = \"o\", cex = 0.2, col = \"cornflowerblue\", \n         xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\", xlim = range(ss))\n    axis(4)\n    mtext(\"Sunset (blue)\", 4, line = 2.7, cex = 1)\n    axis(1, at = seq(min(ss), max(ss), by = (10 * 24 * 60 * \n                                               60)), labels = F)\n    axis(1, at = seq(min(ss), max(ss), by = (30 * 24 * 60 * \n                                               60)), lwd.ticks = 2, labels = trunc(seq(min(ss), \n                                                                                       max(ss), by = (30 * 24 * 60 * 60)), \"days\"), cex.axis = 1)\n    par(mar = c(1.5, 4.5, 0.8, 5), bty = \"n\")\n    plot(sr, tab1[, 2], type = \"h\", lwd = 4, col = \"firebrick\", \n         ylab = \"\", xaxt = \"n\", xlim = range(sr), ylim = c(0, \n                                                           max(na.omit(c(tab1[, 2], tab2[, 2])))))\n    if (is.numeric(rise.prob)) \n      abline(h = rise.prob, lty = 2, lwd = 1.5)\n    opar <- par(mar = c(1.5, 4.5, 0.8, 5), bty = \"n\")\n    plot(ss, tab2[, 2], type = \"h\", lwd = 4, col = \"cornflowerblue\", \n         ylab = \"\", xaxt = \"n\", xlim = range(ss), ylim = c(0, \n                                                           max(na.omit(c(tab1[, 2], tab2[, 2])))))\n    if (is.numeric(set.prob)) \n      abline(h = set.prob, lty = 2, lwd = 1.5)\n    mtext(\"Probability of change\", side = 2, at = max(na.omit(c(tab1[, \n                                                                     2], tab2[, 2]))), line = 3)\n    par(mar = c(1, 4.5, 1, 5), bty = \"o\")\n    mig <- out$site\n    mig[mig > 0] <- 1\n    plot(tab[, 1] + (tab[, 2] - tab[, 1])/2, ifelse(out$site > \n                                                      0, 1, 0), type = \"l\", yaxt = \"n\", ylab = NA, ylim = c(0,1.5)) \n    \n    min.r <- aggregate(as.numeric(tab$tFirst[out$site>0]), by = list(out$site[out$site>0]), FUN = function(x) min(x))\n    max.r <- aggregate(as.numeric(tab$tFirst[out$site>0]), by = list(out$site[out$site>0]), FUN = function(x) max(x))\n    \n    rect(min.r[,2], 1.1, max.r[,2], 1.4, col = \"grey90\", lwd = 0)\n    \n    rect(min.r[,2], 1.1, max.r[,2], 1.4, col = ifelse(unique(out$site[out$site>0])%in%unique(tmp02[tmp02$fixed, 5]), \"red\", \"transparent\"),\n         density = 60)\n    \n    par(def.par)\n  }\n  if (summary) {\n    GeoLight:::i.sum.Cl(out)\n  }\n  return(out)\n}\n\n\n#' Function to merge sites\n#'\n#' The \\code{\\link{changeLight}} functions provides a vector grouping the twilight times\n#' into stationary (>0) and movement (0) periods. This function was written to enable the user\n#' to merge sites based on the distance between consequtive sites. NOTE: The function requires\n#' position estimate and desicison on whether sites should be merged will be made based on\n#' the defined \\code{distance}, the \\code{cutoff} values and the provided positions. The analysis\n#' is this dependent on the accuracy of the position estiamtes and should be applied to positons that\n#' were estimated using a sensible sun elevation angle.\n#'\n#' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n#' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n#' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n#' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type}\n#' @param site a \\code{numerical vector} assigning each row to a particular\n#' period. Stationary periods in numerical order and values >0,\n#' migration/movement periods 0. This \\code{vector} will be used as the initial state.\n#' @param degElevation the sun elevation angle (in degrees) that defines twilight (e.g. -6 for \"civil\n##' twilight\"). Either a single value, a \\code{vector} with the same length as\n##' \\code{tFirst} or \\code{nrow(x)}.\n#' @param distThreshold a \\code{numerical} value defining the threshold of the distance under \n#' which consequtive sites should be merged (in km).\n#' @param fixed ...\n#' @param alpha mean and standard variation for position optimization process.\n#' @param plot \\code{logical}, if TRUE a plot comparing the inital and the final site selection.\n#' @return A \\code{vector} with the merged site numbers\n#' @author Simeon Lisovski\n#'\n#' @export mergeSites\n#' @importFrom fields rdist.earth\n#' @importFrom graphics abline axis lines mtext par plot points rect \n#' @importFrom stats optim dnorm\nmergeSites <- function (tFirst, tSecond, type, twl, site, degElevation, distThreshold = 250, \n                        fixed = NULL, alpha = c(0, 15), plot = TRUE) \n{\n  tab <- GeoLight:::i.argCheck(as.list(environment())[sapply(environment(),FUN = function(x) any(class(x) != \"name\"))])\n  site0 <- site\n  if(is.null(fixed)) fixed = matrix(FALSE, nrow = nrow(tab), ncol = 2)\n  tw <- data.frame(datetime = .POSIXct(c(tab$tFirst, tab$tSecond),\"GMT\"), \n                   type = c(tab$type, ifelse(tab$type == 1, 2, 1)),\n                   fixed = c(fixed[,1], fixed[,2]))\n  \n  tw <- tw[!duplicated(tw$datetime), ]\n  tw <- tw[order(tw[, 1]), ]\n  tw <- tw[1:nrow(tab), ]\n  \n  crds0 <- coord(tab, degElevation = degElevation, note = F)\n  fixed.ind <- apply(fixed, 1, function(x) any(x==TRUE))\n  crds0[fixed.ind] <- cbind(NA, NA)\n  tw$lon <- crds0[, 1]\n  tw$lat <- crds0[, 2]\n  lonlim <- range(crds0[, 1], na.rm = T)\n  lon.seq <- seq(lonlim[1] - 1, lonlim[2] + 1, by = 1)\n  latlim <- range(crds0[, 2], na.rm = T)\n  lat.seq <- seq(latlim[1] - 1, latlim[2] + 1, by = 1)\n  mod <- function(x) {\n    loglik <- function(crds) {\n      t.tw <- twilight(x[, 1], lon = crds[1], lat = crds[2], \n                       rise = ifelse(x[, 2] == 1, TRUE, FALSE), zenith = 90 - \n                         degElevation)\n      diff <- as.numeric(difftime(x[, 1], t.tw, units = \"mins\"))\n      -sum(dnorm(diff, alpha[1], alpha[2], log = T), na.rm = T)\n    }\n    fit0 <- optim(cbind(median(x[, 4], na.rm = T), median(x[,5], na.rm = T)), \n                  loglik, lower = cbind(lonlim[1], latlim[1]), upper = cbind(lonlim[2], latlim[2]), \n                  method = \"L-BFGS-B\", hessian = T)\n    fit <- optim(cbind(fit0$par[1], fit0$par[2]), loglik, \n                 lower = cbind(lonlim[1], latlim[1]), upper = cbind(lonlim[2], \n                                                                    latlim[2]), method = \"L-BFGS-B\", hessian = T)\n    fisher_info <- solve(fit$hessian)\n    prop_sigma <- sqrt(diag(fisher_info))\n    prop_sigma <- diag(prop_sigma)\n    lon.lower <- c(fit$par[1] - 1.96 * prop_sigma)[1]\n    lat.lower <- c(fit$par[2] - 1.96 * prop_sigma)[4]\n    lon.upper <- c(fit$par[1] + 1.96 * prop_sigma)[1]\n    lat.upper <- c(fit$par[2] + 1.96 * prop_sigma)[4]\n    matrix(c(fit$par[1], fit$par[2], lon.lower, lat.lower, \n             lon.upper, lat.upper), ncol = 6)\n  }\n  out <- data.frame(site = unique(site[site != 0 & !fixed.ind]), t(sapply(split(tw[site != 0 & !fixed.ind, ], \n                                                                                f = site[site != 0 & !fixed.ind]), mod)))\n  \n  rep = TRUE\n  ite = 1\n  repeat {\n    for (i in site[site != 0 & !duplicated(site) & !fixed.ind]) {\n      if(i==max(out$site)) break\n      dist0 <- fields:::rdist.earth(out[which(out[,1]==i):(which(out[,1]==i) + 1), 2:3])[2, 1]\n      if (dist0 <= distThreshold) \n        break\n    }\n    if (i < max(site[site != 0 & !duplicated(site) & !fixed.ind])) {\n      site[(which(site == i)[1]):(which(site == (i + 1))[sum(site == (i + 1))])] <- i\n      site[which(site > i)] <- site[which(site > i)] - 1\n    } else rep = FALSE\n    out <- data.frame(site = unique(site[site != 0 & !fixed.ind]), t(sapply(split(tw[site != 0 & !fixed.ind, ], \n                                                                                  f = site[site != 0 & !fixed.ind]), mod)))\n    if (!rep) \n      break\n    else ite <- ite + 1\n  }\n  \n  if(any(fixed)) {\n    fs <- site[site != 0 & !duplicated(site) & fixed.ind]\n    out.temp <- as.data.frame(cbind(fs, matrix(NA, nrow = length(fs), ncol = ncol(out)-1)))\n    names(out.temp) <- names(out)\n    out <- rbind(out, out.temp)\n    out <- out[order(out[,1]),]\n  }\n  \n  \n  if (plot) {\n    hours0 <- as.numeric(format(tw[, 1], \"%H\")) + as.numeric(format(tw[, \n                                                                       1], \"%M\"))/60\n    crd0 <- out[match(site, out$site), 2:3]\n    crd0[!is.na(crd0[, 1]), ] <- crds0[!is.na(crd0[, 1]), \n                                       ]\n    hours1 <- twilight(tw[, 1], rise = ifelse(tw[, 2] == \n                                                1, TRUE, FALSE), zenith = 90 - degElevation, lon = out[match(site, \n                                                                                                             out$site), 2], lat = out[match(site, out$site), 3])\n    hours1 <- as.numeric(format(hours1, \"%H\")) + as.numeric(format(hours1, \n                                                                   \"%M\"))/60\n    hours2 <- twilight(tw[, 1], rise = ifelse(tw[, 2] == \n                                                1, TRUE, FALSE), zenith = 90 - degElevation, lon = out[match(site, \n                                                                                                             out$site), 4], lat = out[match(site, out$site), 3])\n    hours2 <- as.numeric(format(hours2, \"%H\")) + as.numeric(format(hours2, \n                                                                   \"%M\"))/60\n    hours3 <- twilight(tw[, 1], rise = ifelse(tw[, 2] == \n                                                1, TRUE, FALSE), zenith = 90 - degElevation, lon = out[match(site, \n                                                                                                             out$site), 6], lat = out[match(site, out$site), 3])\n    hours3 <- as.numeric(format(hours3, \"%H\")) + as.numeric(format(hours3, \n                                                                   \"%M\"))/60\n    for (t in 1:2) {\n      cor <- rep(NA, 24)\n      for (i in 0:23) {\n        cor[i + 1] <- max(abs((c(hours0[tw$type == t][1], \n                                 hours0[tw$type == t]) + i)%%24 - (c(hours0[tw$type == \n                                                                              t], hours0[tw$type == t][length(hours0)]) + \n                                                                     i)%%24), na.rm = T)\n      }\n      hours0[tw$type == t] <- (hours0[tw$type == t] + (which.min(round(cor, \n                                                                       2))) - 1)%%24\n      hours1[tw$type == t] <- (hours1[tw$type == t] + (which.min(round(cor, \n                                                                       2))) - 1)%%24\n      hours2[tw$type == t] <- (hours2[tw$type == t] + (which.min(round(cor, \n                                                                       2))) - 1)%%24\n      hours3[tw$type == t] <- (hours3[tw$type == t] + (which.min(round(cor, \n                                                                       2))) - 1)%%24\n    }\n    \n    opar <- par(mfrow = c(5, 1), oma = c(5, 0, 0, 0), mar = c(1.5, \n                                                              5, 1, 1))\n    mig1 <- site0\n    mig1[mig1 > 0] <- 1\n    mig2 <- site\n    mig2[mig2 > 0] <- 1\n    plot(tw[, 1], ifelse(mig2 > 0, 1, 0), type = \"l\", yaxt = \"n\", \n         ylab = NA, ylim = c(0, 1.5), col = \"firebrick\", lwd = 2, \n         xaxt = \"n\")\n    lines(tw[, 1], ifelse(mig1 > 0, 1, 0), type = \"l\", lty = 2)\n    \n    \n    rect(tw[site > 0 & !duplicated(site), 1], 1.1, tw[site > 0 & !duplicated(site, fromLast = T), 1], 1.4,\n         lwd = 0, col = \"grey\")\n    \n    rect(tw[site > 0 & !duplicated(site), 1], 1.1, tw[site > 0 & !duplicated(site, fromLast = T), 1], 1.4, \n         col = ifelse(unique(site[site>0])%in%unique(site[fixed.ind & site>0]), \"red\", \"transparent\"),\n         density = 60)\n    \n    axis(1, at = seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n         labels = FALSE)\n    plot(tw[tw[, 2] == 1, 1], hours1[tw[, 2] == 1], type = \"l\", \n         lwd = 2, col = \"firebrick\", ylab = \"Sunrise (red)\", \n         xlim = range(tw[, 1]), ylim = range(hours0[tw[, 2] == \n                                                      1]), xaxt = \"n\")\n    lines(tw[tw[, 2] == 1, 1], hours2[tw[, 2] == 1], type = \"l\", \n          lwd = 1, lty = 2)\n    lines(tw[tw[, 2] == 1, 1], hours3[tw[, 2] == 1], type = \"l\", \n          lwd = 1, lty = 2)\n    points(tw[tw[, 2] == 1 & !tw$fixed, 1], hours0[tw[, 2] == 1 & !tw$fixed], cex = 0.5, \n           pch = 21, col = \"black\", bg = \"firebrick\", lwd = 0.5)\n    axis(1, at = seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n         labels = FALSE)\n    plot(tw[tw[, 2] == 2, 1], hours1[tw[, 2] == 2], type = \"l\", \n         lwd = 2, col = \"cornflowerblue\", ylab = \"Sunset (blue)\", \n         xlim = range(tw[, 1]), ylim = range(hours0[tw[, 2] == \n                                                      2]), xaxt = \"n\")\n    lines(tw[tw[, 2] == 2, 1], hours2[tw[, 2] == 2], type = \"l\", \n          lwd = 1, lty = 2)\n    lines(tw[tw[, 2] == 2, 1], hours3[tw[, 2] == 2], type = \"l\", \n          lwd = 1, lty = 2)\n    points(tw[tw[, 2] == 2 & !tw$fixed, 1], hours0[tw[, 2] == 2 & !tw$fixed], cex = 0.5, \n           pch = 21, col = \"black\", bg = \"cornflowerblue\", lwd = 0.5)\n    axis(1, at = seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n         labels = FALSE)\n    plot(tw[, 1], crds0[, 1], type = \"o\", pch = 16, cex = 0.5, \n         xaxt = \"n\", ylab = \"Longitude\", cex.lab = 1.7, xlab = \"\")\n    abline(v = c(tw[site0 > 0 & !duplicated(site0), 1], tw[site0 > \n                                                             0 & !duplicated(site0, fromLast = T), 1]), lty = 2)\n    abline(v = c(tw[site > 0 & !duplicated(site), 1], tw[site > \n                                                           0 & !duplicated(site, fromLast = T), 1]), lwd = 1.5, \n           col = \"firebrick\")\n    axis(1, at = seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n         labels = FALSE)\n    plot(tw[, 1], crds0[, 2], type = \"o\", pch = 16, cex = 0.5, \n         xaxt = \"n\", ylab = \"Latitude\", cex.lab = 1.7, xlab = \"\")\n    abline(v = c(tw[site0 > 0 & !duplicated(site0), 1], tw[site0 > \n                                                             0 & !duplicated(site0, fromLast = T), 1]), lty = 2)\n    abline(v = c(tw[site > 0 & !duplicated(site), 1], tw[site > \n                                                           0 & !duplicated(site, fromLast = T), 1]), lwd = 1.5, \n           col = \"firebrick\")\n    axis(1, at = seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n         labels = format(seq(tw[1, 1], tw[nrow(tw), 1], length = 10), \n                         \"%d-%b\"))\n    mtext(\"Date\", 1, outer = T, line = 1.6, cex = 1.2)\n    par(opar)\n  }\n  names(out) <- c(\"site\", \"Lon\", \"Lat\", \"Lon.upper\", \"Lat.upper\", \n                  \"Lon.lower\", \"Lat.lower\")\n  list(site = site, summary = out)\n}\n\n\n\n\n\n##' Filter for unrealistic positions within a track based on distance\n##'\n##' The filter identifies unrealistic positions. The maximal distance per\n##' hour/day can be set corresponding to the particular species.\n##'\n##' Note that this type of filter significantly depends on the calibration\n##' (\\code{degElevation}). Especially during equinox periods. In contrast, the\n##' (\\code{loessFilter}) is independent from positions (uses twilight times) \n##' and therefore superior.\n##'\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param degElevation sun elevation angle in degrees (e.g. -6 for \"civil\n##' twilight\")\n##' @param distance the maximal distance in km per \\code{units}. Distances above\n##' will be considered as unrealistic.\n##' @param units the time unite corresponding to the distance. Default is\n##' \"hour\", alternative option is \"day\".\n##' @return Logical \\code{vector}. TRUE means the particular position passed the filter.\n##' @author Simeon Lisovski, Fraenzi Korner-Nievergelt\n##' @importFrom stats loess\n##' @export distanceFilter\ndistanceFilter <- function(tFirst, tSecond, type, twl, degElevation = -6, distance, units = \"hour\") {\n  \n  tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])   \n  \n  if(units==\"days\") units <- distance/24\n  \n  tFirst <- as.POSIXct(tab$tFirst, tz = \"GMT\")\n  tSecond<- as.POSIXct(tab$tSecond, tz = \"GMT\")\n  type <- tab$type\n  tSunTransit <- tFirst + (tSecond-tFirst)/2\n  crds  <- coord(tab, degElevation, note=FALSE)\n  \n  crds[is.na(crds[,2]),2] <- 999\n  \n  difft <- as.numeric(difftime(tSunTransit[-length(tSunTransit)],tSunTransit[-1],units=\"hours\"))\n  diffs <- abs(as.numeric(i.loxodrom.dist(crds[-nrow(crds), 1], crds[-nrow(crds), 2], crds[-1, 1], crds[-1, 2]))/difft)\n  \n  index <- rep(TRUE,length(tFirst))\n  index[diffs>distance] <- FALSE\n  index[crds[,2]==999] <- TRUE\n  \n  \n  cat(paste(\"Note: \",length(index[!index]),\" of \",length(index[crds[,2]!=999]),\" positions were filtered (\",floor((length(index[!index])*100)/length(index[crds[,2]!=999])),\" %)\",sep=\"\"))\n  index\n}\n\n\n#' Transformation of *.gle files\n#'\n#' Function to transform *.gle files derived by the software GeoLocator for\n#' further analyses in \\bold{\\code{GeoLight}}.\n#'\n#' The *.gle file derived by the software \"GeoLocator\" (Swiss Ornithological\n#' Institute) is a table with interpolated light intensities over time gathered\n#' from the *.glf file. Furthermore a column defines wether the light intensity\n#' passes the defined light intensity threshold in the morning (sunrise) or in\n#' the evening (sunset). This information is used in \\code{gleTrans()}, to\n#' create a table with two subsequent twilight events (\\emph{tFirst, tSecond})\n#' and \\emph{type} defining wether \\emph{tFirst} refers to sunrise (1) or\n#' sunset (2). Date and time information will be transferred into a\n#' \\code{GeoLight} appropriate format (see: \\code{\\link{as.POSIXct}}).\n#'\n#' @param file the full patch and filename with suffix of the *.gle file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Simeon Lisovski\n#' @seealso \\code{\\link{glfTrans}}\n#' @importFrom utils read.table\n#' @export gleTrans\ngleTrans <- function(file) {\n  \n  \n  gle1 <- read.table(file,sep=\"\\t\",skip=16,col.names=c(\"date\",\"light\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"type\")) # read file\n  gle1 <- subset(gle1,gle1$type>0,select=c(\"date\",\"type\"))\n  \n  # Date transformation\n  year   <- as.numeric(substring(gle1$date,7,10))\n  month  <- as.numeric(substring(gle1$date,4,5))\n  day    <- as.numeric(substring(gle1$date,1,2))\n  hour   <- as.numeric(substring(gle1$date,12,13))\n  min    <- as.numeric(substring(gle1$date,15,16))\n  gmt.date <- paste(year,\"-\", month,\"-\",day,\" \",hour,\":\",min,\":\",0,sep=\"\")\n  gmt.date <- as.POSIXct(strptime(gmt.date, \"%Y-%m-%d %H:%M:%S\"), \"UTC\")\n  \n  gle <- data.frame(date=gmt.date,type=gle1$type)\n  \n  \n  opt <- data.frame(tFirst=as.POSIXct(\"1900-01-01 01:01\",\"UTC\"),tSecond=as.POSIXct(\"1900-01-01 01:01\",\"UTC\"),type=0)\n  \n  row <- 1\n  for (i in 1:(length(gmt.date)-1))\n  {\n    if (abs(as.numeric(difftime(gle$date[i],gle$date[i+1],units=\"hours\")))< 18 & gle$date[i] != gle$date[i+1])\n    {\n      opt[row,1] <- gle$date[i]\n      opt[row,2] <- gle$date[i+1]\n      opt[row,3] <- gle$type[i]\n      \n      row <- row+1\n    }\n  }\n  \n  return(opt)\n}\n\n#' Transformation of *.glf files\n#'\n#' Transform *.glf files derived by the software GeoLocator for further\n#' analyses in \\bold{\\code{GeoLight}}.\n#'\n#' The *.glf files produced by the software GeoLocator (Swiss Ornithological\n#' Institute) is a table with light intensity measurements over time.\n#' \\code{glfTrans} produces a table with these measurements and transfer the\n#' data and time information into the format required by \\bold{\\code{GeoLight}}\n#' format (see: \\code{\\link{as.POSIXct}}).\n#'\n#' @param file the full patch and filename with suffix of the *.glf file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Simeon Lisovski\n#' @seealso \\code{\\link{gleTrans}}; \\code{\\link{luxTrans}} for transforming\n#' *.lux files produced by \\emph{Migrate Technology Ltd}\n#' @importFrom utils read.table\n#' @export glfTrans\nglfTrans <- function(file=\"/path/file.glf\") {\n  \n  \n  glf1 <- read.table(file,sep=\"\\t\",skip=6,col.names=c(\"datetime\",\"light\",\"1\",\"2\",\"3\")) # read file\n  \n  # Date transformation\n  year   <- as.numeric(substring(glf1$datetime,7,10))\n  month  <- as.numeric(substring(glf1$datetime,4,5))\n  day    <- as.numeric(substring(glf1$datetime,1,2))\n  hour   <- as.numeric(substring(glf1$datetime,12,13))\n  min    <- as.numeric(substring(glf1$datetime,15,16))\n  gmt.date <- paste(year,\"-\", month,\"-\",day,\" \",hour,\":\",min,\":\",0,sep=\"\")\n  gmt.date <- as.POSIXct(strptime(gmt.date, \"%Y-%m-%d %H:%M:%S\"), \"UTC\")\n  \n  glf <- data.frame(datetime=gmt.date,light=glf1$light)\n  \n  return(glf)\n}\n\n#' Hill-Ekstrom calibration\n#'\n#' Hill-Ekstrom calibration for one or multiple stationary periods.\n#'\n#' The \\emph{Hill-Ekstrom calibration} has been suggested by Hill & Braun\n#' (2001) and Ekstrom (2004), and allows for calibrating data during stationary\n#' periods at unknown latitudinal positions. The Hill-Ekstrom calibration bases\n#' on an increasing error range in latitudes with an increasing mismatch\n#' between light level threshold and the used sun angle. This error is strongly\n#' amplified with proximity to the equinox times due to decreasing slope of day\n#' length variation with latitude. Furthermore, the sign of the error switches\n#' at the equinox, i.e. latitude is overestimated before the equinox and\n#' underestimated after the equinox (or vice versa depending on autumnal/vernal\n#' equinox, hemisphere, and sign of the mismatch between light level threshold\n#' and sun angle). When calculating the positions of a stationary period, the\n#' variance in latitude is minimal if the sun elevation angle fits to the\n#' defined light level threshold. Moreover, the accuracy of positions increases\n#' with decreasing variance in latitudes. \\bold{However, the method is only\n#' applicable for stationary periods and under stable shading intensities}. The\n#' plot produced by the function may help to judge visually if the calculated\n#' sun elevation angles are realistic (e.g. site 2 in the example below) or not\n#' (e.g. site 3 in the example below.\n#'\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param site a \\code{numerical vector} assigning each row to a particular\n##' period. Stationary periods in numerical order and values >0,\n##' migration/movement periods 0\n##' @param start.angle a single sun elevation angle. The combined process of\n##' checking for minimal variance in resulting latitude, which is the initial\n##' value for the sun elevation angle in the iterative process of identifying\n##' the latitudes with the least variance\n##' @param distanceFilter logical, if TRUE the \\code{\\link{distanceFilter}} will\n##' be used to filter unrealistic positions\n##' @param distance if \\code{distanceFilter} is set \\code{TRUE} a threshold\n##' distance in km has to be set (see: \\code{\\link{distanceFilter}})\n##' @param plot logical, if TRUE the function will give a plot with all relevant\n##' information\n##' @return A \\code{vector} of sun elevation angles corresponding to the\n##' Hill-Ekstrom calibration for each defined period.\n##' @author Simeon Lisovski\n##' @references Ekstrom, P.A. (2004) An advance in geolocation by light.\n##' \\emph{Memoirs of the National Institute of Polar Research}, Special Issue,\n##' \\bold{58}, 210-226.\n##'\n##' Hill, C. & Braun, M.J. (2001) Geolocation by light level - the next step:\n##' Latitude. In: \\emph{Electronic Tagging and Tracking in Marine Fisheries}\n##' (eds J.R. Sibert & J. Nielsen), pp. 315-330. Kluwer Academic Publishers, The\n##' Netherlands.\n##'\n##' Lisovski, S., Hewson, C.M, Klaassen, R.H.G., Korner-Nievergelt, F.,\n##' Kristensen, M.W & Hahn, S. (2012) Geolocation by light: Accuracy and\n##' precision affected by environmental factors. \\emph{Methods in Ecology and\n##' Evolution}, DOI: 10.1111/j.2041-210X.2012.00185.x.\n##' @examples\n##'\n##' data(hoopoe2)\n##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n##' residency <- with(hoopoe2, changeLight(tFirst,tSecond,type, rise.prob=0.1, \n##'                   set.prob=0.1, plot=FALSE, summary=FALSE))\n##' HillEkstromCalib(hoopoe2,site = residency$site)\n##'\n##' @importFrom grDevices grey.colors\n##' @importFrom graphics abline axis mtext legend lines par plot points text\n##' @importFrom stats var na.omit\n##' @export HillEkstromCalib\nHillEkstromCalib <- function(tFirst, tSecond, type, twl, site, start.angle=-6, distanceFilter=FALSE, distance, plot=TRUE) {\n  \n  tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])   \n  \n  tFirst <- tab$tFirst\n  tSecond <- tab$tSecond\n  type <- tab$type\n  \n  sites <- as.numeric(length(levels(as.factor(site[as.numeric(site)!=0]))))\n  \n  HECalib <- rep(NA,sites)\n  \n  \n  for(j in 1:sites) {\n    b <- 0\n    start <- start.angle\n    \n    repeat{\n      # backwards\n      if(start-((b*0.1)-0.1) < -9) {\n        HECalib[j] <- NA\n        break\n      }\n      t0 <- var(na.omit(coord(tab[site==j,], degElevation = start-((b*0.1)-0.1), note = F)[,2]))\n      t1 <- var(na.omit(coord(tab[site==j,], degElevation = start-(b*0.1), note = F)[,2]))\n      t2 <- var(na.omit(coord(tab[site==j,], degElevation = start-((b*0.1)+0.1), note = F)[,2]))\n      if(sum(is.na(c(t0,t1,t2)))>0) {\n        HECalib[j] <- NA\n        break\n      }\n      if(t0>t1 & t1<t2) {\n        HECalib[j] <- start-(b*0.1)\n        break}\n      \n      # forward\n      if(start-((b*0.1)-0.1) > 9) {\n        HECalib[j] <- NA\n        break\n      }\n      f0 <- var(na.omit(coord(tab[site==j,], degElevation = start+((b*0.1)-0.1), note = F)[,2]))\n      f1 <- var(na.omit(coord(tab[site==j,], degElevation = start+(b*0.1), note = F)[,2]))\n      f2 <- var(na.omit(coord(tab[site==j,], degElevation = start+((b*0.1)+0.1), note = F)[,2]))\n      if(sum(is.na(c(f0,f1,f2)))>0) {\n        HECalib[j] <- NA\n        break\n      }\n      if(f0>f1 & f1<f2) {\n        HECalib[j] <- start+(b*0.1)\n        break}\n      \n      b <- b+1\n    }\n  }\n  \n  if(plot) {\n\n      opar <- par(mfrow = c(sites, 2), oma = c(3, 5, 6, 2), mar = c(2, 2, 2, 2))\n      for(j in 1:sites){\n        \n        if(is.na(HECalib[j])){\n          \n          plot(0,0,cex=0,pch=20,col=\"white\",ylab=\"\",xlab=\"\",xaxt=\"n\",yaxt=\"n\", bty = \"n\")\n          text(0,0,\"NA\",cex=2)\n          plot(0,0,cex=0,pch=20,col=\"white\",ylab=\"\",xlab=\"\",xaxt=\"n\",yaxt=\"n\", bty=\"n\")\n          \n        } else {\n          \n          angles <- c(seq(HECalib[j]-2,HECalib[j]+2,0.2))\n          \n          latM <- matrix(ncol=length(angles),nrow=length(tFirst[site==j]))\n          \n          for(i in 1:ncol(latM)){\n            latM[,i] <- coord(tab[site==j,], degElevation = c(angles[i]),note=F)[,2]\n          }\n          \n          latT <- latM\n          var1 <- rep(NA,ncol(latT))\n          n1   <- rep(NA,ncol(latT))\n          min  <- rep(NA,ncol(latT))\n          max  <- rep(NA,ncol(latT))\n          for(t in 1:length(var1)){\n            var1[t] <- var(na.omit(latT[,t]))\n            n1[t]   <- length(na.omit(latT[,t]))\n            min[t]  <- if(length(na.omit(latT[,t]))<=1) NA else min(na.omit(latT[,t]))\n            max[t]  <- if(length(na.omit(latT[,t]))<=1) NA else max(na.omit(latT[,t]))\n          }\n          \n          \n          colors <- grey.colors(length(angles))\n          plot(tFirst[site==j],latT[,1],ylim=c(min(na.omit(min)),max(na.omit(max))),type=\"o\",cex=0.7,pch=20,col=colors[1],ylab=\"\",xlab=\"\")\n          for(p in 2:ncol(latT)){\n            lines(tFirst[site==j],latM[,p],type=\"o\",cex=0.7,pch=20,col=colors[p])\n          }\n          lines(tFirst[site==j],coord(tab[site==j,], degElevation = HECalib[j], note=F)[,2],col=\"tomato2\",type=\"o\",lwd=2,cex=1,pch=19)\n          if(j==sites) mtext(\"Latitude\",side=2,line=3)\n          if(j==sites) mtext(\"Date\",side=1,line=2.8)\n          \n          plot(angles,var1,type=\"o\",cex=1,pch=20,ylab=\"\")\n          lines(angles,var1,type=\"p\",cex=0.5,pch=7)\n          abline(v=HECalib[j],lty=2,col=\"red\",lwd=1.5)\n          par(new=T)\n          plot(angles,n1,type=\"o\",xaxt=\"n\",yaxt=\"n\",col=\"blue\",pch=20,ylab=\"\")\n          points(angles,n1,type=\"p\",cex=0.5,pch=8,col=\"blue\")\n          axis(4)\n          if(j==sites) mtext(\"Sun elevation angles\",side=1,line=2.8)\n          legend(\"topright\",c(paste(HECalib[j],\" degrees\",sep=\"\"),\"sample size\",\"variance\"),pch=c(-1,20,20),lty=c(2,2,2),lwd=c(1.5,0,0),col=c(\"red\",\"blue\",\"black\"),bg=\"White\")\n        }\n      }\n      \n      mtext(\"Hill-Ekstrom Calibration\",cex=1.5,line=0.8,outer=T)\n      par(opar)\n\n  }\n  \n  \n  return(HECalib)\n}\n\n\n\ni.JC2000 <- function(jD) {\n  \n  #--------------------------------------------------------------------------------------------------------\n  # jD: julian Date\n  #--------------------------------------------------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  jC<- (jD - 2451545)/36525\n  \n  return(jC)\n  \n}\n\ni.deg <- function(Rad) {\n  \n  #------------------------------------------------------------\n  # Deg: \tThe input angle in radian\n  #------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  return(Rad * (180/pi))\n  \n}\n\ni.frac <- function(In) {\n  \n  #------------------------------------------------------------\n  # In: \tnumerical Number\n  #------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  return(In - floor(In))\n  \n}\n\ni.get.outliers<-function(residuals, k=3) {\n  x <- residuals\n  # x is a vector of residuals\n  # k is a measure of how many interquartile ranges to take before saying that point is an outlier\n  # it looks like 3 is a good preset for k\n  QR<-quantile(x, probs = c(0.25, 0.75))\n  IQR<-QR[2]-QR[1]\n  Lower.band<-QR[1]-(k*IQR)\n  Upper.Band<-QR[2]+(k*IQR)\n  delete<-which(x<Lower.band |  x>Upper.Band)\n  return(as.vector(delete))\n}\n\ni.julianDate <- function(year,month,day,hour,min) {\n  \n  #--------------------------------------------------------------------------------------------------------\n  # Year:\t\tYear as numeric e.g. 2010\n  # Month:\tMonth as numeric e.g.   1\n  # Day:\t\tDay as numeric e.g.\t\t1\n  # Hour:\t\tHour as numeric e.g.   12\n  # Min:\t\tMinunte as numeric e.g. 0\n  #--------------------------------------------------------------------------------------------------------\n  \n  options(digits=15)\n  \n  fracOfDay\t<- hour/24 + min/1440\n  \n  # Julian date (JD)\n  # ------------------------------------\n  \n  index1 <- month <= 2\n  if(sum(index1) > 0)\n  {\n    year[index1]  <- year[index1] -1\n    month[index1] <- month[index1] +12\n  }\n  \n  index2 <- (year*10000)+(month*100)+day <= 15821004\n  \n  JD <- numeric(length(year))\n  if(sum(index2)>0)\n  {\n    JD[index2] <- floor(365.25*(year[index2]+4716)) + floor(30.6001*(month[index2]+1)) + day[index2] + fracOfDay[index2] - 1524.5\n  }\n  index3 <- year*10000+month*100+day >= 15821015\n  if (sum(index3)>0)\n  {\n    a <- floor(year/100)\n    b <- 2 - a + floor(a/4)\n    \n    JD[index3] <- floor(365.25*(year[index3]+4716)) + floor(30.6001*(month[index3]+1)) + day[index3] + fracOfDay[index3] + b[index3] - 1524.5\n  }\n  JD[!index2&!index3] <- 1\n  \n  return(JD)\n  \n}\n\ni.loxodrom.dist <- function(x1, y1, x2, y2, epsilon=0.0001){\n  dis<-numeric(length(x1))\n  rerde<-6368\n  deltax<-abs(x2*pi/180-x1*pi/180)\n  deltay<-abs(y2*pi/180-y1*pi/180)\n  tga<-deltax/(log(tan(pi/4+y2*pi/360))-log(tan(pi/4+y1*pi/360)))\n  \n  dis[abs(x1-x2)<epsilon&abs(y1-y2)<epsilon]<-0\n  dis[abs(y1-y2)<epsilon&(abs(x1-x2)>epsilon)]<-abs(cos(y1[abs(y1-y2)<epsilon&(abs(x1-x2)>epsilon)]*pi/180)*deltax[abs(y1-y2)<epsilon&(abs(x1-x2)>epsilon)])\n  dis[(tga<0)&(abs(x1-x2)>epsilon)&(abs(y1-y2)>epsilon)]<-abs(deltay[(tga<0)&(abs(x1-x2)>epsilon)&(abs(y1-y2)>epsilon)]/cos((pi-atan(tga[(tga<0)&(abs(x1-x2)>epsilon)&(abs(y1-y2)>epsilon)]))))\n  dis[(tga>=0)&(abs(x1-x2)>epsilon)&(y1-y2>epsilon)]<--deltay[(tga>=0)&(abs(x1-x2)>epsilon)&(y1-y2>epsilon)]/cos(atan(tga[(tga>=0)&(abs(x1-x2)>epsilon)&(y1-y2>epsilon)]))\n  dis[(tga>=0)&(abs(x1-x2)>epsilon)&(y2-y1>epsilon)]<-abs(deltay[(tga>=0)&(abs(x1-x2)>epsilon)&(y2-y1>epsilon)]/cos(atan(tga[(tga>=0)&(abs(x1-x2)>epsilon)&(y2-y1>epsilon)])))\n  dis[(abs(x1-x2)<epsilon)&(y2-y1>epsilon)]<-abs(deltay[(abs(x1-x2)<epsilon)&(y2-y1>epsilon)]/cos(atan(tga[(abs(x1-x2)<epsilon)&(y2-y1>epsilon)])))\n  dis[(abs(x1-x2)<epsilon)&(y1-y2>epsilon)]<-abs(deltay[(abs(x1-x2)<epsilon)&(y1-y2>epsilon)]/cos(atan(tga[(abs(x1-x2)<epsilon)&(y1-y2>epsilon)])))\n  dis*rerde\n}\n\ni.preSelection <- function(datetime, light, LightThreshold){\n  \n  dt <- cut(datetime,\"1 hour\")\n  st <- as.POSIXct(levels(dt),\"UTC\")\n  \n  raw <- data.frame(datetime=dt,light=light)\n  \n  h  <- tapply(light,dt,max)\n  df1 <- data.frame(datetime=st+(30*60),light=as.numeric(h))\n  \n  smooth <- i.twilightEvents(df1[,1], df1[,2], LightThreshold)\n  smooth <- data.frame(id=1:nrow(smooth),smooth)\n  raw    <- i.twilightEvents(datetime, light, LightThreshold)\n  raw <- data.frame(id=1:nrow(raw),raw)\n  \n  ind2 <- rep(NA,nrow(smooth))\n  for(i in 1:nrow(smooth)){\n    tmp <- subset(raw,datetime>=(smooth[i,2]-(90*60)) & datetime<=(smooth[i,2]+(90*60)))\n    \n    if(smooth[i,3]==1) ind3 <- tmp$id[which.min(tmp[,2])]\n    if(smooth[i,3]==2) ind3 <- tmp$id[which.max(tmp[,2])]\n    ind2[i] <- ind3\n  }\n  \n  \n  res <- data.frame(raw,mod=1)\n  res$mod[ind2] <- 0\n  \n  return(res)\n}\n\ni.rad <- function(Deg) {\n  \n  #------------------------------------------------------------\n  # Deg: \tThe input angle in degrees\n  #------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  return(Deg * (pi/180))\n  \n}\n\ni.radDeclination <- function(radEclipticalLength,radObliquity) {\n  \n  #-------------------------------------------------------------------------------------------------------------------\n  # RadEclipticLength: The angle between an object's rotational axis, and a line perpendicular to its orbital plane.\n  # EadObliquity:\n  #-------------------------------------------------------------------------------------------------------------------\n  \n  options(digits=10)\n  \n  dec <- asin(sin(radObliquity)*sin(radEclipticalLength))\n  \n  return(dec)\n  \n}\n\ni.radEclipticLongitude <- function(jC) {\n  \n  #-------------------------------------------------------------------------------------------------------------------\n  # jC: Number of julian centuries from the julianian epoch J2000 (2000-01-01 12:00\n  #-------------------------------------------------------------------------------------------------------------------\n  \n  \n  \n  options(digits=10)\n  \n  radMeanAnomaly <- 2*pi*i.frac(0.993133 + 99.997361*jC)\n  EclipticLon    <- 2*pi*i.frac(0.7859452 + radMeanAnomaly/(2*pi) + (6893*sin(radMeanAnomaly) + 72*sin(2*radMeanAnomaly) + 6191.2*jC) / 1296000)\n  \n  return(EclipticLon)\n  \n}\n\ni.radGMST <- function(jD,jD0,jC,jC0) {\n  \n  #--------------------------------------------------------------------------------------------------------\n  # jD:  Julian Date with Hour and Minute\n  # jD0: Julan Date at t 0 UT\n  # jC:  Number of julian centuries from the julianian epoch J2000 (2000-01-01 12:00)\n  # jC0: Number of julian centuries from the julianian epoch J2000 (2000-01-01 12:00) at t 0 UT\n  #--------------------------------------------------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  UT  <- 86400 * (jD-jD0)\n  st0 <- 24110.54841 + 8640184.812866*jC0 + 1.0027379093*UT + (0.093104 - 0.0000062*jC0)*jC0*jC0\n  gmst<- (((2*pi)/86400)*(st0%%86400))\n  \n  return(gmst)\n  \n}\n\ni.radObliquity <- function(jC) {\n  \n  #--------------------------------------------------------------------------------------------------------\n  # jC: Number of julian centuries from the julianian epoch J2000 (2000-01-01 12:00)\n  #--------------------------------------------------------------------------------------------------------\n  \n  options(digits=10)\n  \n  \n  degObliquity <- 23.43929111 - (46.8150 + (0.00059 - 0.001813 *jC)*jC) *jC/3600\n  radObliquity <- i.rad(degObliquity)\n  \n  return(radObliquity)\n  \n}\n\ni.radRightAscension <- function(RadEclipticalLength,RadObliquity) {\n  \n  #-------------------------------------------------------------------------------------------------------------------\n  # RadEclipticLength: The angle between an object's rotational axis, and a line perpendicular to its orbital plane.\n  # EadObliquity:\n  #-------------------------------------------------------------------------------------------------------------------\n  \n  options(digits=10)\n  \n  index1 <- (cos(RadEclipticalLength) < 0)\n  \n  res <- numeric(length(RadEclipticalLength))\n  if (sum(index1)>0)\n  {\n    res[index1] <- (atan((cos(RadObliquity[index1])*sin(RadEclipticalLength[index1]))/cos(RadEclipticalLength[index1])) + pi)\n  }\n  \n  index2 <- (cos(RadEclipticalLength) >= 0)\n  if (sum(index2)>0)\n  {\n    res[index2] <- (atan((cos(RadObliquity[index2])*sin(RadEclipticalLength[index2]))/cos(RadEclipticalLength[index2])))\n  }\n  \n  \n  return(res)\n  \n}\n\ni.setToRange <- function(Start,Stop,Angle) {\n  \n  #-------------------------------------------------------------------------------------------------------------------\n  # Start:\t Minimal value of the range in degrees\n  # Stop: \t Maximal value of the range in degrees\n  # Angle:\t The angle that should be fit to the range\n  #-------------------------------------------------------------------------------------------------------------------\n  \n  options(digits=15)\n  \n  angle <- Angle\n  range <- Stop - Start\n  \n  \n  \n  index1 <- angle >= Stop\n  if (sum(index1, na.rm = T)>0) angle[index1] <- angle[index1] - (floor((angle[index1]-Stop)/range)+1)*range\n  \n  index2 <- angle < Start\n  if(sum(index2, na.rm = T)>0) angle[index2] <- angle[index2]  + ceiling(abs(angle[index2] -Start)/range)*range\n  \n  return(angle)\n  \n}\n\ni.sum.Cl <- function(object) {\n  \n  if(all(names(object)%in%c(\"riseProb\",\"setProb\",\"rise.prob\",\"set.prob\",\"site\",\"migTable\"))){\n    cat(\"\\n\")\n    cat(\"Probability threshold(s):\")\n    cat(rep(\"\\n\",2))\n    if(!is.na(object$rise.prob)) cat(paste(\"\tSunrise: \",object$rise.prob))\n    if(!is.na(object$set.prob)) cat(paste(\"\tSunset: \",object$set.prob))\n    cat(rep(\"\\n\",3))\n    cat(\"Migration schedule table:\")\n    cat(rep(\"\\n\",2))\n    \n    print(object$migTable,quote=FALSE)\n  } else {\n    cat(\"Error: List must be the output list of the changeLight function.\")\n  }\n}\n\n\n#' Filter to remove noise in light intensity measurements during the night\n#'\n#' The filter identifies and removes light intensities oczillating around the\n#' baseline or few light intensities resulting in a short light peak during the\n#' night. Such noise during the night will increase the calculated twilight\n#' events using the function \\code{\\link{twilightCalc}} and therewith the\n#' manual work to remove these false twilight events.\n#'\n#' The filter searches for light levels above the baseline and compares the\n#' prior and posterior levels. If these values are below the threshold the\n#' particular light level will be reduced to the baseline. A few (usually two)\n#' iterations might be enough to remove most noise during the night (however,\n#' not if such noise occurs at the begining or at the end were not enough prior\n#' or posterior values are available).\n#'\n#' @param light \\code{numerical} value of the light intensity (usually\n#' arbitrary units).\n#' @param baseline the light intensity baseline (no light). If \\code{Default},\n#' it will be calculated as the most frequent value below the mean light\n#' intensities.\n#' @param iter a \\code{numerical} value, specifying how many iterations should\n#' be computed (see details).\n#' @return numerical \\code{vector} with the new light levels. Same length as\n#' the initial light vector.\n#' @author Simeon Lisovski\n#' @examples\n#'\n#' night <- rep(0,50); night[runif(4,0,50)] <- 10; night[runif(4,0,50)] <- -5\n#' nightday <- c(night,rep(30,50))\n#' plot(nightday,type=\"l\",ylim=c(-5,30),ylab=\"light level\",xlab=\"time (time)\")\n#' light2 <- lightFilter(nightday, baseline=0, iter=4)\n#' lines(light2,col=\"red\")\n#' legend(\"bottomright\",c(\"before\",\"after\"),lty=c(1,1),col=c(\"black\",\"red\"),bty=\"n\")\n#'\n#' @export lightFilter\nlightFilter <- function(light, baseline=NULL, iter=2){\n  \n  r <- as.data.frame(table(light))\n  r[,1] <- as.character(r[,1])\n  nr <- as.numeric(which.max(r$Freq[as.numeric(r[,1])<mean(light)]))\n  LightThreshold <- ifelse(is.null(baseline),as.numeric(r[nr,1]),baseline)\n  \n  light[light<LightThreshold] <- LightThreshold\n  \n  \n  index <- which(light<mean(light) & light!= LightThreshold)\n  \n  rep   <- rep(FALSE,length(light))\n  \n  for(i in 1:iter){\n    \n    for(i in index[index>5 & index<(length(light)-5)]){\n      \n      back=FALSE\n      if(any(light[seq(i-5,i)]==LightThreshold)) back <- TRUE\n      forw=FALSE\n      if(any(light[seq(i,i+5)]==LightThreshold)) forw <- TRUE\n      \n      if(back & forw) rep[i] <- TRUE\n      \n    }\n    \n    light[rep] <- LightThreshold\n    \n  }\n  \n  light\n}\n\n\n##' Filter to remove outliers in defined twilight times based on smoother function\n##'\n##' This filter defines outliers based on residuals from a local polynomial\n##' regression fitting provcess (\\code{\\link{loess}}).\n##'\n##'\n##' @param tFirst vector of sunrise/sunset times (e.g. 2008-12-01 08:30).\n##' @param tSecond vector of of sunrise/sunset times (e.g. 2008-12-01 17:30).\n##' @param type vector of either 1 or 2, defining \\code{tFirst} as sunrise or sunset respectively.\n##' @param twl data.frame containing twilights and at least \\code{tFirst}, \\code{tSecond} and \\code{type} (alternatively give each parameter separately).\n##' @param k a measure of how many interquartile ranges to take before saying\n##' that a particular twilight event is an outlier\n##' @param plot codelogical, if TRUE a plot indicating the filtered times will\n##' be produced.\n##' @return Logical \\code{vector} matching positions that pass the filter.\n##' @author Simeon Lisovski & Eldar Rakhimberdiev\n##' @importFrom graphics axis mtext legend lines par plot points\n##' @importFrom stats loess predict residuals\n##' @export loessFilter\nloessFilter <- function(tFirst, tSecond, type, twl, k = 3, plot = TRUE){\n  \n  tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])   \n  \n  tw <- data.frame(datetime = .POSIXct(c(tab$tFirst, tab$tSecond), \"GMT\"), \n                   type = c(tab$type, ifelse(tab$type == 1, 2, 1)))\n  tw <- tw[!duplicated(tw$datetime),]\n  tw <- tw[order(tw[,1]),]\n  \n  hours <- as.numeric(format(tw[,1],\"%H\"))+as.numeric(format(tw[,1],\"%M\"))/60\n  \n  for(t in 1:2){\n    cor <- rep(NA, 24)\n    for(i in 0:23){\n      cor[i+1] <- max(abs((c(hours[tw$type==t][1],hours[tw$type==t])+i)%%24 -\n                            (c(hours[tw$type==t],hours[tw$type==t][length(hours)])+i)%%24),na.rm=T)\n    }\n    hours[tw$type==t] <- (hours[tw$type==t] + (which.min(round(cor,2)))-1)%%24\n  }\n  \n  dawn <- data.frame(id=1:sum(tw$type==1),\n                     datetime=tw$datetime[tw$type==1],\n                     type=tw$type[tw$type==1],\n                     hours = hours[tw$type==1], filter=FALSE)\n  \n  dusk <- data.frame(id=1:sum(tw$type==2),\n                     datetime=tw$datetime[tw$type==2],\n                     type=tw$type[tw$type==2],\n                     hours = hours[tw$type==2], filter=FALSE)\n  \n  \n  for(d in seq(30,k,length=5)){\n    \n    predict.dawn <- predict(loess(dawn$hours[!dawn$filter]~as.numeric(dawn$datetime[!dawn$filter]),span=0.1))\n    predict.dusk <- predict(loess(dusk$hours[!dusk$filter]~as.numeric(dusk$datetime[!dusk$filter]),span=0.1))\n    \n    del.dawn <-\ti.get.outliers(as.vector(residuals(loess(dawn$hours[!dawn$filter]~\n                                                           as.numeric(dawn$datetime[!dawn$filter]),span=0.1))),k=d)\n    del.dusk <-\ti.get.outliers(as.vector(residuals(loess(dusk$hours[!dusk$filter]~\n                                                           as.numeric(dusk$datetime[!dusk$filter]),span=0.1))),k=d)\n    \n    if(length(del.dawn)>0) dawn$filter[!dawn$filter][del.dawn] <- TRUE\n    if(length(del.dusk)>0) dusk$filter[!dusk$filter][del.dusk] <- TRUE\n  }\n  \n  if(plot){\n    opar <- par(mfrow=c(2,1),mar=c(3,3,0.5,3),oma=c(2,2,0,0))\n    plot(dawn$datetime[dawn$type==1],dawn$hours[dawn$type==1],pch=\"+\",cex=0.6,xlab=\"\",ylab=\"\",yaxt=\"n\")\n    lines(dawn$datetime[!dawn$filter], predict(loess(dawn$hours[!dawn$filter]~as.numeric(dawn$datetime[!dawn$filter]),span=0.1)) , type=\"l\")\n    points(dawn$datetime[dawn$filter],dawn$hours[dawn$filter],col=\"red\",pch=\"+\",cex=1)\n    axis(2,labels=F)\n    mtext(\"Sunrise\",4,line=1.2)\n    \n    plot(dusk$datetime[dusk$type==2],dusk$hours[dusk$type==2],pch=\"+\",cex=0.6,xlab=\"\",ylab=\"\",yaxt=\"n\")\n    lines(dusk$datetime[!dusk$filter], predict(loess(dusk$hours[!dusk$filter]~as.numeric(dusk$datetime[!dusk$filter]),span=0.1)), type=\"l\")\n    points(dusk$datetime[dusk$filter],dusk$hours[dusk$filter],col=\"red\",pch=\"+\",cex=1)\n    axis(2,labels=F)\n    legend(\"bottomleft\",c(\"OK\",\"Filtered\"),pch=c(\"+\",\"+\"),col=c(\"black\",\"red\"),\n           bty=\"n\",cex=0.8)\n    mtext(\"Sunset\",4,line=1.2)\n    mtext(\"Time\",1,outer=T)\n    mtext(\"Sunrise/Sunset hours (rescaled)\",2,outer=T)\n    par(opar)\n  }\n  all <- rbind(subset(dusk,filter),subset(dawn,filter))\n  \n  filter <- rep(FALSE,length(tab$tFirst))\n  filter[as.POSIXct(tab$tFirst, \"GMT\")%in%all$datetime | as.POSIXct(tab$tSecond, \"GMT\")%in%all$datetime] <- TRUE\n  \n  return(!filter)\n}\n\n\n#' Transformation of *.lux files\n#'\n#' Transform *.lux files derived from \\emph{Migrate Technology Ltd} geolocator\n#' deviced for further analyses in \\bold{\\code{GeoLight}}.\n#'\n#' The *.lux files produced by \\emph{Migrate Technology Ltd} are table with\n#' light intensity measurements over time. \\code{luxTrans} produces a table\n#' with these measurements and transfer the data and time information into the\n#' format required by \\bold{\\code{GeoLight}} format (see:\n#' \\code{\\link{as.POSIXct}}).\n#'\n#' @param file the full patch and filename with suffix of the *.lux file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Simeon Lisovski\n#' @seealso \\code{\\link{gleTrans}} for transforming *.glf files produced by the\n#' software GeoLocator (\\emph{Swiss Ornithological Institute})\n#' @importFrom utils read.table\n#' @export luxTrans\nluxTrans <- function(file) {\n  \n  lux1 <- read.table(file,sep=\"\\t\",skip=21,col.names=c(\"datetime\",\"time\")) # read file\n  lux <- data.frame(datetime=as.POSIXct(strptime(lux1[,1],format=\"%d/%m/%Y %H:%M:%S\",tz=\"UTC\")),light=lux1[,2])\n  \n  return(lux)\n}\n\n\n#' Transformation of *.lig files\n#'\n#' Transform *.lig files derived from geolocator\n#' deviced for further analyses in \\bold{\\code{GeoLight}}.\n#'\n#' @param file the full patch and filename with suffix of the *.lux file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Tamara Emmenegger\n#' @seealso \\code{\\link{gleTrans}} for transforming *.glf files produced by the\n#' software GeoLocator (\\emph{Swiss Ornithological Institute})\n#' @importFrom utils read.csv\n#' @export ligTrans\nligTrans <- function(file) {\n  df <- cbind(read.csv(file,row.names=NULL)[,c(2,4)])\n  colnames(df) <- c(\"datetime\", \"light\")\n  df$datetime <- as.POSIXct(strptime(df$datetime,format=\"%d/%m/%y %H:%M:%S\",tz=\"UTC\"))\n  return(df)\n}\n\n#' Transformation of staroddi files\n#'\n#' Transform staroddi files derived from geolocator\n#' deviced for further analyses in \\bold{\\code{GeoLight}}.\n#'\n#' @param file the full patch and filename of the staroddi file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Tamara Emmenegger\n#' @importFrom utils read.table\n#' @export staroddiTrans\nstaroddiTrans <- function(file){\n  df <- cbind(read.table(file,sep=\"\\t\")[,c(2,4)])\n  colnames(df) <- c(\"datetime\", \"light\")\n  df$datetime <- as.POSIXct(strptime(df$datetime,format=\"%d/%m/%y %H:%M:%S\",tz=\"UTC\"))\n  return(df)\n}\n\n\n#' Transformation of *.trn files\n#'\n#' Transform *.trn files derived from geolocator\n#' deviced for further analyses in \\bold{\\code{GeoLight}}.\n#'\n#' @param file the full patch and filename of the *.trn file.\n#' @return A \\code{data.frame} suitable for further use in\n#' \\bold{\\code{GeoLight}}.\n#' @author Tamara Emmenegger\n#' @importFrom utils read.table\n#' @export trnTrans\ntrnTrans<-function(file){\n  data<-read.table(file,sep=\",\")\n  tFirst <- vector(\"numeric\",length=(length(data[,1])-1))\n  tSecond <- vector(\"numeric\",length=(length(data[,1])-1))\n  type <- vector(\"numeric\",length=(length(data[,1])-1))\n  for (i in 1:(length(data[,1])-1)){\n    date1<-as.Date(substr(as.character(data$V1[i]),1,8),format=\"%d/%m/%y\")\n    tFirst[i] <- as.POSIXct(paste(as.character(date1),prefix=substr(as.character(data$V1[i]),10,17)),tz=\"UTC\")\n    date2<-as.Date(substr(as.character(data$V1[i+1]),1,8),format=\"%d/%m/%y\")\n    tSecond[i] <- as.POSIXct(paste(as.character(date1),prefix=substr(as.character(data$V1[i+1]),10,17)),tz=\"UTC\")\n    if(as.character(data$V2[i])==\"Sunrise\") type[i] <- 1\n    if(as.character(data$V2[i])==\"Sunset\") type[i] <- 2\n  }\n  output <- data.frame(tFirst=as.POSIXlt(tFirst,origin=\"1970-01-01\",tz=\"UTC\"),tSecond=as.POSIXlt(tSecond,origin=\"1970-01-01\",tz=\"UTC\"),type=type)\n  return(output)\n}\n\n\n\n## ' Summary of migration/movement pattern\n##'\n##' Function for making a data frame summarising residency and movement pattern.\n##'\n##' @param tFirst date and time of sunrise/sunset (e.g. 2008-12-01 08:30)\n##' @param tSecond date and time of sunrise/sunset (e.g. 2008-12-01 17:30)\n##' @param site a \\code{vector}, indicating the residency period of a particular\n##' day (see output: \\code{\\link{changeLight}})\n##' @return A \\code{data.frame} with end and start date (yyyy-mm-dd hh:mm, UTC)\n##' for each stationary period.\n##' @author Simeon Lisovski\n##' @examples\n##' data(hoopoe2)\n##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n##' residency <- changeLight(hoopoe2, rise.prob=0.1, set.prob=0.1, plot=FALSE, summary=FALSE)\n##' schedule(hoopoe2[,1], hoopoe2[,2], site = residency$site)\n##' @export schedule\nschedule <- function(tFirst, tSecond, site) {    \n  tm <- tFirst + (tSecond - tFirst)/2\n  \n  arr <- tm[!is.na(site) & !duplicated(site)]\n  dep <- tm[!is.na(site) & !duplicated(site, fromLast = T)]\n  \n  out <- data.frame(Site =  letters[1:length(arr)], Arrival = arr, Departure = dep)\n  if(!is.na(site[1])) out$Arrival[1] <- NA\n  if(!is.na(site[length(tFirst)])) out$Departure[nrow(out)] <- NA\n  \n  out\n}\n\n\n\ni.twilightEvents <- function (datetime, light, LightThreshold) \n{\n  df <- data.frame(datetime, light)\n  ind1 <- which((df$light[-nrow(df)] < LightThreshold & df$light[-1] > \n                   LightThreshold) | (df$light[-nrow(df)] > LightThreshold & \n                                        df$light[-1] < LightThreshold) | df$light[-nrow(df)] == \n                  LightThreshold)\n  bas1 <- cbind(df[ind1, ], df[ind1 + 1, ])\n  bas1 <- bas1[bas1[, 2] != bas1[, 4], ]\n  x1 <- as.numeric(unclass(bas1[, 1]))\n  x2 <- as.numeric(unclass(bas1[, 3]))\n  y1 <- bas1[, 2]\n  y2 <- bas1[, 4]\n  m <- (y2 - y1)/(x2 - x1)\n  b <- y2 - (m * x2)\n  xnew <- (LightThreshold - b)/m\n  type <- ifelse(bas1[, 2] < bas1[, 4], 1, 2)\n  res <- data.frame(datetime = as.POSIXct(xnew, origin = \"1970-01-01\", \n                                          tz = \"UTC\"), type)\n  return(res)\n}\n\n#' Draws sites of residency and adds a convex hull\n#'\n#' Draw a map (from the \\code{R} Package \\code{maps}) showing the defined\n#' stationary sites\n#'\n#'\n#' @param crds a \\code{SpatialPoints} or \\code{matrix} object, containing x\n#' and y coordinates (in that order).\n#' @param site a \\code{numerical vector} assigning each row to a particular\n#' period. Stationary periods in numerical order and values >0,\n#' migration/movement periods 0.\n#' @param type either \\emph{points}, or \\emph{cross} to show all points for each site or only show the mean position of the site with standard deviation.\n#' @param quantiles the quantile of the error bars (\\emph{cross}) around the median.\n#' @param hull \\code{logical}, if TRUE a convex hull will be plotted around the points of each site.\n#' @param map.range some possibilities to choose defined areas (\"World\n#' (default)\", \"EuroAfrica\",\"America\",\"AustralAsia\").\n#' @param ... Arguments to be passed to methods, such as graphical parameters (see par).\n#' @details Standard graphical paramters like \\code{pch}, \\code{cex}, \\code{lwd}, \\code{lty} and \\code{col} are implemented. \n#' The color can be specified as either a vector of colors (e.g. c(\"blue\", \"red\", ...)) or as a character string indicating a color ramp (at the moment only \"random\" and \"rainbow\" is available )\n#' @author Simeon Lisovski & Tamara Emmenegger\n#' @examples\n#' data(hoopoe2)\n#'  hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n#'  hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n#' crds <- coord(hoopoe2, degElevation = -6)\n#' filter <- distanceFilter(hoopoe2, distance = 30)\n#' site <- changeLight(hoopoe2, rise.prob = 0.1, set.prob = 0.1, plot = FALSE, \n#'  summary = FALSE)$site\n#' siteMap(crds[filter,], site[filter], xlim=c(-20,20), ylim=c(0,60), \n#'  lwd=2, pch=20, cex=0.5, main=\"hoopoe2\")\n#'\n#' @importFrom maps map map.axes\n#' @importFrom grDevices chull col2rgb rainbow rgb\n#' @importFrom graphics legend mtext par plot points segments\n#' @export siteMap\nsiteMap <- function(crds, site, type = \"points\", quantiles = c(0.25, 0.75), hull = T, \n                    map.range = c(\"EuroAfrica\", \"AustralAsia\", \"America\", \"World\"), ...) {  \n  args <- list(...)\n  \n  if(all(map.range==c(\"EuroAfrica\", \"AustralAsia\", \"America\", \"World\")) & sum(names(args)%in%c(\"xlim\", \"ylim\"))!=2) {\n    range <- c(-180, 180, -80, 90)\n  } \n  if(all(map.range==\"EuroAfrica\")) range <- c(-24, 55, -55, 70)\n  if(all(map.range==\"AustralAsia\")) range <- c(60, 190, -55, 78)\n  if(all(map.range==\"America\")) range <- c(-170, -20, -65, 78)\n  if(all(map.range==\"World\")) range <- c(-180, 180, -75, 90)\n  \n  if(sum(names(args)%in%c(\"xlim\", \"ylim\"))==2) range <- c(args$xlim, args$ylim)\n  \n  # colors for sites\n  areColors <- function(x) {\n    sapply(x, function(X) {\n      tryCatch(is.matrix(col2rgb(X)), \n               error = function(e) FALSE)\n    })\n  }\n  \n  \n  if(any(names(args)%in%\"col\")) {\n    allcolors <- rainbow(60,v=0.85)[1:50]\n    if(any(args$col==\"rainbow\")) {\n      col <- allcolors[round(seq(1,50,length.out=length(unique(site))))]\n    }\n    if(any(args$col==\"random\")) {\n      col <- sample(allcolors[round(seq(1,50,length.out=length(unique(site))))],length(unique(site)),replace = FALSE)\n    }\n    if(!any(args$col%in%c(\"random\", \"rainbow\"))) {\n      if(!any(areColors(args$col))) stop(\"invalid colors\", call. = FALSE)\n      if(length(args$col)!=length(unique(site))) {\n        col = rep(args$col, length(unique(site)))[1:length(unique(site))]\n        warning(\"Length of color vector is not equal to number of sites!\", call. = FALSE)\n      }\n    }\n  } else {\n    allcolors <- rainbow(60,v=0.85)[1:50]\n    col <- sample(allcolors[round(seq(1,50,length.out=length(unique(site))))],length(unique(site)),replace = FALSE)\n  }\n  \n  \n  if(sum(names(args)%in%\"add\")==1) add <- args$add else add = FALSE\n  \n  \n  if(!add) {\n    opar <- par(mar = c(6,5,1,1))\n    plot(NA, xlim=c(range[1],range[2]), ylim=c(range[3],range[4]), xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\", bty = \"n\")\n    map(xlim=c(range[1],range[2]), ylim=c(range[3],range[4]), fill=T, lwd=0.01, col=c(\"grey90\"), add=TRUE)\n    mtext(ifelse(sum(names(args)%in%\"xlab\")==1, args$xlab, \"Longitude\"), side=1, line=2.2, font=3)\n    mtext(ifelse(sum(names(args)%in%\"ylab\")==1, args$ylab, \"Latitude\"), side=2, line=2.5, font=3)\n    map.axes()\n    mtext(ifelse(sum(names(args)%in%\"main\")==1, args$main, \"\"), line=0.6, cex=1.2)\n  }\n  \n  \n  if(type==\"points\") {\n    points(crds[site>0, ], \n           cex = ifelse(any(names(args)==\"cex\"), args$cex, 0.5),\n           pch = ifelse(any(names(args)==\"pch\"), args$pch, 16),\n           col = col[as.numeric(site)])\n  }\n  if(type==\"cross\") {\n    for (i in 1:max(unique(site))){\n      if(!all(is.na(crds[site==i, 2]))){\n        tmp.lon <- quantile(crds[site == i, 1], probs = c(quantiles, 0.5), na.rm = T)\n        tmp.lat <- quantile(crds[site == i, 2], probs = c(quantiles, 0.5), na.rm = T)\n        points(tmp.lon[3], tmp.lat[3],\n               col = col[i],\n               cex = ifelse(any(names(args)==\"cex\"), args$cex, 1),\n               pch = ifelse(any(names(args)==\"pch\"), args$pch, 16))\n        segments(tmp.lon[1], tmp.lat[3], tmp.lon[2], tmp.lat[3],\n               col = col[i],\n               lwd = ifelse(any(names(args)==\"lwd\"), args$lwd, 2))\n        segments(tmp.lon[3], tmp.lat[1], tmp.lon[3], tmp.lat[2],\n               col = col[i],\n               lwd = ifelse(any(names(args)==\"lwd\"), args$lwd, 2))\n      }\n    }\n  }    \n  \n  \n  if(hull) {\n    for(j in unique(site)){\n          if(!all(is.na(crds[site==j, 2]))){\n          if(j>0){\n            X <- na.omit(crds[site==j,])\n            hpts <- chull(X)\n            hpts <- c(hpts,hpts[1])\n            lines(X[hpts,], \n                 lty = ifelse(sum(names(args)%in%\"lty\")==1, args$lty, 1),\n                       lwd = ifelse(sum(names(args)%in%\"lwd\")==1, args$lwd, 1),\n                       col = col[j])\n        }\n      }\n    }\n  }\n  \n  legend(\"bottomright\", letters[1:max(site)], \n         pch = ifelse(sum(names(args)%in%\"pch\")==1, args$pch, 16),\n         col=col[1:max(as.numeric(site))])\n  \n  if(!add) par(opar)\n}\n\n\n\n##' Write a file which plots a trip in Google Earth\n##'\n##' This function creates a .kml file from light intensity measurements over\n##' time that can ve viewed as a trip in Google Earth.\n##'\n##'\n##' @param file A character expression giving the whole path and the name of the\n##' resulting output file including the .kml extension.\n##' @param tFirst date and time of sunrise/sunset (e.g. 2008-12-01 08:30)\n##' @param tSecond date and time of sunrise/sunset (e.g. 2008-12-01 17:30)\n##' @param type either 1 or 2, defining \\code{tFirst} as sunrise or sunset\n##' respectively\n##' @param degElevation sun elevation angle in degrees (e.g. -6 for \"civil\n##' twilight\"). Either a single value, a \\code{vector} with the same length as\n##' \\code{tFirst}.\n##' @param col.scheme the color scheme used for the points. Possible color\n##' schemes are: \\code{\\link{rainbow}}, \\code{\\link{heat.colors}},\n##' \\code{\\link{topo.colors}}, \\code{\\link{terrain.colors}}.\n##' @param point.alpha a \\code{numerical value} indicating the transparency of\n##' the point colors on a scale from 0 (transparent) to 1 (opaque).\n##' @param cex \\code{numerical value} for the size of the points.\n##' @param line.col An character expression (any of \\code{\\link{colors}} or\n##' hexadecimal notation), or numeric indicating the color of the line\n##' connecting the point locations.\n##' @return This function returns no data. It creates a .kml file in the in the\n##' defined path.\n##' @author Simeon Lisovski and Michael U. Kemp\n##' @examples\n##' \\donttest{\n##' data(hoopoe2)\n##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n##' filter <- distanceFilter(hoopoe2,distance=30)\n##' ## takes time\n##' ## trip2kml(\"trip.kml\", hoopoe2$tFirst[filter], hoopoe2$tSecond[filter], hoopoe2$type[filter],\n##' ##\t\tdegElevation=-6, col.scheme=\"heat.colors\", cex=0.7,\n##' ##\t\tline.col=\"goldenrod\")\n##'}\n##' @importFrom grDevices rgb\n##' @export trip2kml\ntrip2kml <- function(file, tFirst, tSecond, type, degElevation, col.scheme=\"heat.colors\", point.alpha=0.7, cex=1, line.col=\"goldenrod\")\n{\n  if((length(tFirst)+length(type))!=(length(tSecond)+length(type))) stop(\"tFirst, tSecond and type must have the same length.\")\n  \n  coord   <- coord(tFirst,tSecond,type,degElevation,note=F)\n  index <- !is.na(coord[,2])\n  datetime <- as.POSIXct(strptime(paste(ifelse(type==1,substring(tFirst,1,10),substring(tSecond,1,10)),\n                                        \" \",ifelse(type==1,\"12:00:00\",\"00:00:00\"),sep=\"\"),format=\"%Y-%m-%d %H:%M:%S\"),\"UTC\")\n  \n  coord   <- coord[index,]\n  longitude <- coord[,1]\n  latitude <- coord[,2]\n  \n  date <- unlist(strsplit(as.character(datetime[index]), split = \" \"))[seq(1,\n                                                                           ((length(datetime[index]) * 2) - 1), by = 2)]\n  time <- unlist(strsplit(as.character(datetime[index]), split = \" \"))[seq(2,\n                                                                           ((length(datetime[index]) * 2)), by = 2)]\n  \n  if(length(!is.na(coord[,2]))<1) stop(\"Calculation of coordinates results in zero spatial information.\")\n  \n  if ((col.scheme%in% c(\"rainbow\", \"heat.colors\", \"terrain.colors\", \"topo.colors\",\n                        \"cm.colors\"))==F) stop(\"The col.scheme has been misspecified.\")\n  \n  seq   <- seq(as.POSIXct(datetime[1]),as.POSIXct(datetime[length(datetime)]),by=12*60*60)\n  index2<- ifelse(!is.na(merge(data.frame(d=datetime[index],t=TRUE),data.frame(d=seq,t=FALSE),by=\"d\",all.y=T)[,2]),TRUE,FALSE)\n  \n  usable.colors <- strsplit(eval(parse(text = paste(col.scheme,\n                                                    \"(ifelse(length(index2) < 1000, length(index2), 1000), alpha=point.alpha)\",\n                                                    sep = \"\"))), split = \"\")[index2]\n  \n  usable.line.color <- strsplit(rgb(col2rgb(line.col)[1,\n                                                      1], col2rgb(line.col)[2, 1], col2rgb(line.col)[3,\n                                                                                                     1], col2rgb(line.col, alpha = 1)[4, 1], maxColorValue = 255),\n                                split = \"\")\n  \n  date <- unlist(strsplit(as.character(datetime), split = \" \"))[seq(1,\n                                                                    ((length(datetime) * 2) - 1), by = 2)]\n  time <- unlist(strsplit(as.character(datetime), split = \" \"))[seq(2,\n                                                                    ((length(datetime) * 2)), by = 2)]\n  scaling.parameter <- rep(cex, length(latitude))\n  \n  data.variables <- NULL\n  filename <- file\n  write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\", filename)\n  write(\"<kml xmlns=\\\"http://www.opengis.net/kml/2.2\\\">\", filename,\n        append = TRUE)\n  write(\"<Document>\", filename, append = TRUE)\n  write(paste(\"<name>\", filename, \"</name>\", sep = \" \"),\n        filename, append = TRUE)\n  \n  write(\"  <open>1</open>\", filename, append = TRUE)\n  write(\"\\t<description>\", filename, append = TRUE)\n  write(\"\\t  <![CDATA[Generated using <a href=\\\"http://simeonlisovski.wordpress.com/geolight\\\">GeoLight</a>]]>\",\n        filename, append = TRUE)\n  write(\"\\t</description>\", filename, append = TRUE)\n  write(\"<Folder>\", filename, append = TRUE)\n  write(\"  <name>Points</name>\", filename, append = TRUE)\n  write(\"<open>0</open>\", filename, append = TRUE)\n  for (i in 1:length(latitude)) {\n    write(\"<Placemark id='point'>\", filename, append = TRUE)\n    write(paste(\"<name>\", as.character(as.Date(datetime[i])), \"</name>\", sep = \"\"),\n          filename, append = TRUE)\n    write(\"  <TimeSpan>\", filename, append = TRUE)\n    write(paste(\"    <begin>\", date[i], \"T\", time[i], \"Z</begin>\",\n                sep = \"\"), filename, append = TRUE)\n    write(paste(\"    <end>\", date[ifelse(i == length(latitude),\n                                         i, i + 1)], \"T\", time[ifelse(i == length(latitude),\n                                                                      i, i + 1)], \"Z</end>\", sep = \"\"), filename, append = TRUE)\n    write(\"  </TimeSpan>\", filename, append = TRUE)\n    write(\"<visibility>1</visibility>\", filename, append = TRUE)\n    write(\"<description>\", filename, append = TRUE)\n    write(paste(\"<![CDATA[<TABLE border='1'><TR><TD><B>Variable</B></TD><TD><B>Value</B></TD></TR><TR><TD>Date/Time</TD><TD>\",\n                datetime[i], \"</TD></TR><TR><TD>lat long</TD><TD>\",\n                paste(latitude[i], longitude[i], sep = \" \"),\n                \"</TABLE>]]>\", sep = \"\", collapse = \"\"), filename,\n          append = TRUE)\n    write(\"</description>\", filename, append = TRUE)\n    write(\"\\t<Style>\", filename, append = TRUE)\n    write(\"\\t<IconStyle>\", filename, append = TRUE)\n    write(paste(\"\\t\\t<color>\", paste(noquote(usable.colors[[i]][c(8,\n                                                                  9, 6, 7, 4, 5, 2, 3)]), collapse = \"\"), \"</color>\",\n                sep = \"\"), filename, append = TRUE)\n    write(paste(\"  <scale>\", scaling.parameter[i], \"</scale>\",\n                sep = \"\"), filename, append = TRUE)\n    write(\"\\t<Icon>\", filename, append = TRUE)\n    write(\"\\t\\t<href>http://maps.google.com/mapfiles/kml/pal2/icon26.png</href>\",\n          filename, append = TRUE)\n    write(\"\\t</Icon>\", filename, append = TRUE)\n    write(\"\\t</IconStyle>\", filename, append = TRUE)\n    write(\"\\t</Style>\", filename, append = TRUE)\n    write(\"\\t<Point>\", filename, append = TRUE)\n    write(paste(\"\\t<altitudeMode>\", \"relativeToGround\", \"</altitudeMode>\",\n                sep = \"\"), filename, append = TRUE)\n    write(\"<tesselate>1</tesselate>\", filename, append = TRUE)\n    write(\"<extrude>1</extrude>\", filename, append = TRUE)\n    write(paste(\"\\t  <coordinates>\", longitude[i], \",\", latitude[i],\n                \",\", 1,\n                \"</coordinates>\", sep = \"\"), filename, append = TRUE)\n    write(\"\\t</Point>\", filename, append = TRUE)\n    write(\" </Placemark>\", filename, append = TRUE)\n  }\n  \n  write(\"</Folder>\", filename, append = TRUE)\n  write(\"<Placemark>\", filename, append = TRUE)\n  write(\"  <name>Line Path</name>\", filename, append = TRUE)\n  write(\"  <Style>\", filename, append = TRUE)\n  write(\"    <LineStyle>\", filename, append = TRUE)\n  write(paste(\"\\t<color>\", paste(noquote(usable.line.color[[1]][c(8,\n                                                                  9, 6, 7, 4, 5, 2, 3)]), collapse = \"\"), \"</color>\", sep = \"\"),\n        filename, append = TRUE)\n  \n  \n  write(paste(\"      <width>1</width>\", sep = \"\"), filename,\n        append = TRUE)\n  write(\"    </LineStyle>\", filename, append = TRUE)\n  write(\"  </Style>\", filename, append = TRUE)\n  write(\"  <LineString>\", filename, append = TRUE)\n  write(\"    <extrude>0</extrude>\", filename, append = TRUE)\n  write(\"    <tessellate>1</tessellate>\", filename, append = TRUE)\n  write(paste(\"\\t<altitudeMode>clampToGround</altitudeMode>\",\n              sep = \"\"), filename, append = TRUE)\n  write(paste(\"     <coordinates>\", noquote(paste(longitude,\n                                                  \",\", latitude, sep = \"\", collapse = \" \")), \"</coordinates>\",\n              sep = \"\"), filename, append = TRUE)\n  write(\"    </LineString>\", filename, append = TRUE)\n  write(\"</Placemark>\", filename, append = TRUE)\n  write(\"</Document>\", filename, append = TRUE)\n  write(\"</kml>\", filename, append = TRUE)\n}\n\n#' Draw the positions and the trip on a map\n#'\n#' Draw a map (from the \\code{R} Package \\code{maps}) with calculated positions\n#' connected by a line\n#'\n#'\n#' @param crds a \\code{SpatialPoints} or \\code{matrix} object, containing x\n#' and y coordinates (in that order).\n#' @param equinox logical; if \\code{TRUE}, the equinox period(s) is shown as a\n#' broken blue line.\n#' @param map.range some possibilities to choose defined areas (default:\n#' \"World\").\n#' @param ... Arguments to be passed to methods, such as graphical parameters (see par).\n#' @param legend \\code{logical}; if \\code{TRUE}, a legend will be added to the plot.\n#' @author Simeon Lisovski\n#' @examples\n#'\n#' data(hoopoe2)\n#'  hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n#'  hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n#' crds <- coord(hoopoe2, degElevation = -6)\n#' tripMap(crds, xlim = c(-20,20), ylim = c(0,60), main=\"hoopoe2\")\n#'\n#' @importFrom maps map map.axes\n#' @importFrom graphics lines legend mtext par plot points\n#' @export tripMap\ntripMap <- function(crds, equinox=TRUE, map.range=c(\"EuroAfrica\",\"AustralAsia\",\"America\",\"World\"), legend = TRUE, ...) {\n  \n  args <- list(...)\n  if(all(map.range==c(\"EuroAfrica\", \"AustralAsia\", \"America\", \"World\")) & sum(names(args)%in%c(\"xlim\", \"ylim\"))!=2) {\n    range <- c(-180, 180, -80, 90)\n  } \n  if(all(map.range==\"EuroAfrica\")) range <- c(-24, 55, -55, 70)\n  if(all(map.range==\"AustralAsia\")) range <- c(60, 190, -55, 78)\n  if(all(map.range==\"America\")) range <- c(-170, -20, -65, 78)\n  if(all(map.range==\"World\")) range <- c(-180, 180, -75, 90)\n  \n  if(sum(names(args)%in%c(\"xlim\", \"ylim\"))==2) range <- c(args$xlim, args$ylim)\n  \n  if(sum(names(args)%in%\"add\")==1) add <- args$add else add = FALSE\n  \n  if(!add) {\n    opar <- par(mar = c(6,5,1,1))\n    plot(NA,xlim=c(range[1],range[2]),ylim=c(range[3],range[4]), xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\")\n    map(xlim=c(range[1],range[2]),ylim=c(range[3],range[4]), fill=T,lwd=0.01,col=c(\"grey90\"),add=TRUE)\n    map(xlim=c(range[1],range[2]),ylim=c(range[3],range[4]),interior=TRUE,col=c(\"darkgrey\"),add=TRUE)\n    mtext(ifelse(sum(names(args)%in%\"xlab\")==1, args$xlab, \"Longitude\"), side=1, line=2.2, font=3)\n    mtext(ifelse(sum(names(args)%in%\"ylab\")==1, args$ylab, \"Latitude\"), side=2, line=2.5, font=3)\n    map.axes()\n    \n    mtext(ifelse(sum(names(args)%in%\"main\")==1, args$main, \"\"), line=0.6, cex=1.2)\n  }\n  \n  points(crds, \n         pch = ifelse(sum(names(args)%in%\"pch\")==1, args$pch, 3),\n         cex = ifelse(sum(names(args)%in%\"cex\")==1, args$cex, 0.7))\n  lines(crds,\n        lwd = ifelse(sum(names(args)%in%\"lwd\")==1, args$lwd, 0.5),\n        col = ifelse(sum(names(args)%in%\"col\")==1, args$col, \"grey10\"))\n  \n  if(equinox){\n    nrow <- 1\n    repeat{\n      while(is.na(crds[nrow,2])==FALSE) {\n        nrow <- nrow + 1\n        if(nrow==nrow(crds)) break\n      }\n      if(nrow==nrow(crds)) break\n      start   <- nrow-1\n      while(is.na(crds[nrow,2])) {\n        nrow <- nrow + 1\n        if(nrow==nrow(crds)) break\n      }\n      if(nrow==nrow(crds)) break\n      end    <- nrow\n      \n      lines(c(crds[start,1], crds[end,1]),c(crds[start,2], crds[end,2]), col=\"blue\", lwd=3, lty=1)\n    }\n    \n    if(legend) legend(\"bottomright\", lty=c(0,1,1), pch=c(3,-1,-1), lwd=c(1,0.5,3), col=c(\"black\",ifelse(sum(names(args)%in%\"col\")==1, args$col, \"grey10\"),\"blue\"),c(\"Positions\",\"Trip\",\"Equinox\"),bty=\"n\",bg=\"grey90\",border=\"grey90\",cex=0.8)\n  } else {\n    if(legend) \t  legend(\"bottomright\",lty=c(0,1),pch=c(3,-1),lwd=c(1,0.5),col=c(\"black\",ifelse(sum(names(args)%in%\"col\")==1, args$col, \"grey10\"),\"blue\"),c(\"Positions\",\"Trip\"),bty=\"n\",bg=\"grey90\",border=\"grey90\",cex=0.8)\n  }\n  if(!add) par(opar)\n  \n}\n\n#' Calculate twilight events (sunrise/sunset) from light intensity measurements\n#' over time\n#'\n#' Defines twilight events (sunrise/sunset) at times when the light intensity\n#' measurements (\\emph{light}) pass the defined light intensity threshold. An\n#' interactive plot can be drawn to assess the calculations and improve e.g.\n#' select only the realistic events.\n#'\n#'\n#' @param datetime date and time of light intensity measurements e.g.\n#' 2008-12-01 08:30 \"UTC\" (see:\n#' \\code{\\link{as.POSIXct}},\\link[=Sys.timezone]{time zones}).\n#' @param light \\code{numerical} value of the light intensity (usually\n#' arbitrary units).\n#' @param preSelection codelogical, if TRUE a pre selection of all calculated\n#' twiligth events will be offered within the interactive process (ask=TRUE).\n#' @param LightThreshold the light intensity threshold for the twilight event\n#' calibration. If \\code{Default}, it will be set slightly above (3 units) the\n#' baseline level (measurement during the night).\n#' @param maxLight if the geolocator record the maximum light value of a\n#' certain time span, give the interval of maximum recordings in minutes (e.g.\n#' 5).\n#' @param ask \\code{logical}, if TRUE the interactive plot will start after the\n#' calculation.\n#' @param nsee number of points to plot per screen.\n#' @param allTwilights \\code{logical}, if TRUE the function returns a list with\n#' two tables\n#' @return if allTwilights=FALSE, a \\code{data frame}. Each row contains two\n#' subsequent twilight events (\\emph{tFirst, tSecond}) and \\emph{type} defining\n#' wether \\emph{tFirst} refers to sunrise (1) or sunset (2). If\n#' allTwilights=TRUE, a \\code{list} with the data frame described in the\n#' previous sentence and a data frame with all light intensities and a column\n#' describing whether each row refers to sunrise (1), sunset (2) or to none of\n#' these categories (0).\n#' @note Depending on shading during light intensity measurements (e.g. due to\n#' vegetation, weather, etc., see Lisovski et \\emph{al.} 2012) the light\n#' intensities may pass the light intensity threshold several times during the\n#' day, resulting false sunrises and sunsets. It is highly recommended to check\n#' the derived events visually (\\code{ask=TRUE}).Twilight events can be deleted\n#' and undeleted by clicking the (first) mouse button at the particular\n#' position in the graph. The second mouse buttom (or esc) moves the time\n#' series forward. Note, that a backward option is not included.\n#' @author Simeon Lisovski\n#' @export twilightCalc\n#' @importFrom grDevices graphics.off\n#' @importFrom graphics abline axis identify legend plot points \ntwilightCalc <- function(datetime, light, LightThreshold=TRUE, preSelection=TRUE, maxLight=NULL, ask=TRUE, nsee=500, allTwilights=FALSE)\n{\n  if(class(datetime)[1]!=\"POSIXct\") {\n    stop(sprintf(\"datetime need to be provided as POSIXct class object.\"), call. = F)\n    \n  } else {\n    bas <- data.frame(datetime=as.POSIXct(as.character(datetime),\"UTC\"),light)\n  }\n  \n  \n  if (is.numeric(LightThreshold))\n  {\n    LightThreshold <- as.numeric(LightThreshold)\n    min <- min(bas$light)\n  } else {\n    # Basic level\n    r <- as.data.frame(table(bas$light))\n    nr <- as.numeric(which.max(r$Freq[as.numeric(r[,1])<mean(bas$light)]))\n    LightThreshold <- (as.numeric(as.character(r[nr,1])))+3\n  }\n  \n  out <- i.preSelection(bas$datetime,bas$light, LightThreshold)[,-1]\n  \n  if(!preSelection) out$mod <- 0\n  \n  if(ask)\n  {\n    n   <- nrow(bas)\n    nn  <- n%/%nsee + 1\n    cutsub <- cut(1:n, nn)\n    picks <- NULL\n    \n    for(i in 1:nn){\n      sub <- cutsub == levels(cutsub)[i]\n      \n      repeat{\n        plot(bas[sub,1],bas[sub,2],type=\"o\",cex=0.6,pch=20,ylab=\"Light intensity\",xaxs=\"i\",xaxt=\"n\",xlab=\"\",\n             main=paste(as.Date(min(bas[sub,1])),\" to \", as.Date(max(bas[sub,1])),\" (end: \",as.Date(max(bas[,1])),\")\",sep=\"\"))\n        abline(h=LightThreshold,col=\"blue\",lty=2)\n        abline(v=out[out$mod==0,1],col=\"orange\",lty=ifelse(out[out$mod==0,2]==1,1,2))\n        points(out[,1],rep(LightThreshold,nrow(out[,])),col=ifelse(out$mod==0,\"orange\",\"grey\"),pch=20,cex=0.8)\n        \n        axis(1,at=out[seq(from=1,to=nrow(out),length.out=(nrow(out)%/%2)),1],\n             labels=substring(as.character(out[seq(from=1,to=nrow(out),length.out=(nrow(out)%/%2)),1]),6,16),cex=0.7)\n        \n        legend(\"topright\",lty=c(3,1,2),lwd=c(1.3,2,2),col=c(\"blue\",rep(\"orange\",2)),c(\"Light\\nThreshold\",\"sunrise\",\"sunset\"),cex=1,bg=\"white\")\n        \n        nr <- identify(out[,1],rep(LightThreshold,nrow(out)),n=1,plot=F)\n        ifelse(length(nr)>0,ifelse(out$mod[nr]==0,out$mod[nr]<-1,out$mod[nr]<-0),break)\n      }\n    }\n    \n    cat(\"Thank you!\\n\\n\")\n    graphics.off()\n  }\n  \n  results <- list()\n  \n  \n  out <- subset(out,out$mod==0)[,-3]\n  \n  raw <- data.frame(datetime=c(as.POSIXct(datetime,\"UTC\"),as.POSIXct(out$datetime,\"UTC\")),\n                    light=c(light,rep(LightThreshold,nrow(out))),type=c(rep(0,length(datetime)),out$type))\n  \n  raw <- raw[order(raw$type),]\n  raw <- raw[-which(duplicated(as.character(raw$datetime),fromLast=T)),]\n  raw <- raw[order(raw$datetime),]\n  \n  results$allTwilights <- raw\n  \n  opt <- data.frame(tFirst=as.POSIXct(\"1900-01-01 01:01\",\"UTC\"),tSecond=as.POSIXct(\"1900-01-01 01:01\",\"UTC\"),type=0)\n  row <- 1\n  for (k in 1:(nrow(out)-1))\n  {\n    if (as.numeric(difftime(out[k,1],out[k+1,1]))< 24 & out[k,1] != out[k+1,1])\n    {\n      opt[row,1] <- out[k,1]\n      opt[row,2] <- out[k+1,1]\n      opt[row,3] <- out$type[k]\n      \n      row <- row+1\n    }\n  }\n  \n  if(is.numeric(maxLight))\n  {\n    opt$tFirst[opt$type==2] <- opt$tFirst[opt$type==2] - (maxLight*60)\n    opt$tSecond[opt$type==1] <- opt$tSecond[opt$type==1] - (maxLight*60)\n  }\n  \n  if(allTwilights) {\n    results$consecTwilights <- opt\n    return(results)\n  } else {\n    return (opt)}\n}\n\n#' Example data for calibration: Light intensities and twilight events\n#'\n#' Light intensity measurements over time (calib1) recorded at the rooftop of\n#' the Swiss Ornithological Institute (Lon: 8.0, Lat: 47.01). Defined twilight\n#' events from calib1 (calib2). These data serve as an example for calculating\n#' the sun elevation angle of an additional data set, which is subsequently\n#' used to calibrate the focal dataset.\n#'\n#' @name calib1\n#' @docType data\n#' @aliases calib1 calib2 calib\n#' @references Lisovski, S., Hewson, C.M, Klaassen, R.H.G., Korner-Nievergelt,\n#' F., Kristensen, M.W & Hahn, S. (2012) Geolocation by light: Accuracy and\n#' precision affected by environmental factors. \\emph{Methods in Ecology and\n#' Evolution}, DOI: 10.1111/j.2041-210X.2012.00185.x.\n#' @examples\n#'\n#' data(calib2)\n#'  calib2$tFirst <- as.POSIXct(calib2$tFirst, tz = \"GMT\")\n#'  calib2$tSecond <- as.POSIXct(calib2$tSecond, tz = \"GMT\")\n#' getElevation(calib2, known.coord = c(8,47.01))\n#'\nNULL\n\n\n#' Light intensity measurements over time recorded on a migratory bird\n#'\n#' Sunlight intensity measurements over time recorded during the first part of\n#' the annual migration of a European Hoopoe (\\cite{Upupa epops}). All\n#' dates/times are measured in Universal Time Zone (UTC).\n#'\n#'\n#' @name hoopoe1\n#' @docType data\n#' @format A table with 24474 rows and 2 columns, rows corresponding to light\n#' measurements recorded in ten-minute intervals (datetime).\n#' @source Baechler, E., Hahn, S., Schaub, M., Arlettaz, R., Jenni, L., Fox,\n#' J.W., Afanasyev, V. & Liechti, F. (2010) Year-Round Tracking of Small\n#' Trans-Saharan Migrants Using Light-Level Geolocators. \\emph{Plos One},\n#' \\bold{5}.\nNULL\n\n\n#' Sunrise and sunset times: From light intensity measurement (hoopoe1)\n#'\n#' Sunrise and sunset times derived from light intensity measurements over time\n#' (\\code{\\link{hoopoe1}}). The light measurements corresponding to the first\n#' part of the annual migration of a European Hoopoe (\\emph{Upupa epops}).\n#'\n#' @name hoopoe2\n#' @docType data\n#' @format A table with 340 rows and 3 columns. Each row corresponds to\n#' subsequent twilight events (\"tFirst\" and \"tSecond\"). The third column\n#' (\"type\") indicates weather the first event is sunrise (1) or sunset (2). All\n#' dates/times are measured in Universal Time Zone (UTC).\n#' @source Baechler, E., Hahn, S., Schaub, M., Arlettaz, R., Jenni, L., Fox,\n#' J.W., Afanasyev, V. & Liechti, F. (2010) Year-Round Tracking of Small\n#' Trans-Saharan Migrants Using Light-Level Geolocators. \\emph{Plos One},\n#' \\bold{5}.\n#' @examples\n#'\n#' data(hoopoe2)\n#'  hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = \"GMT\")\n#'  hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = \"GMT\")\n#' coord <- coord(hoopoe2, degElevation=-6)\n#' ## plot in a map using package maps\n#' # par(oma=c(5,0,0,0))\n#' # map(xlim=c(-20,40),ylim=c(-10,60),interior=F,col=\"darkgrey\")\n#' # map(xlim=c(-20,40),ylim=c(-10,60),boundary=F,lty=2,col=\"darkgrey\",add=T)\n#' # mtext(c(\"Longitude (degrees)\",\"Latitude (degrees)\"),side=c(1,2),line=c(2.2,2.5),font=3)\n#' # map.axes()\n#' # points(coord,col=\"brown\",cex=0.5,pch=20)\n#'\nNULL",
    "created" : 1444966843451.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2650397459",
    "id" : "39EF1240",
    "lastKnownWriteTime" : 1444969063,
    "path" : "D:/GitHub/GeoLight/R/GeoLight.R",
    "project_path" : "R/GeoLight.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}