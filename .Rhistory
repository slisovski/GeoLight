diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,4], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,5], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
out_ML
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML))
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML)))
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
library(GeoLight)
siteEstimate()
siteEstimate
siteEstimate <- function(tFirst, tSecond, type, twl,
degElevation,
method = "gamma", parms = c(3.3, 0.8),
xlim = c(-180, 180),
ylim = c(-90, 90), res = c(0.5, 0.5)) {
tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])
tw <- data.frame(Twilight = .POSIXct(c(tab$tFirst, tab$tSecond), "GMT"),
Rise = c(ifelse(tab$type==1, TRUE, FALSE), ifelse(tab$type == 1, FALSE, TRUE)))
tw <- tw[!duplicated(tw$Twilight),]
tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(tw$Twilight, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(tw, f = ifelse(1:nrow(tw)<min(eq.ind), 1, ifelse(1:nrow(tw)>max(eq.ind), 2, NA)))
} else {
twl.sp <- list(tw)
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
list(SunElevation = degElevation,
Estimate = out_A,
mlLoc = out_ML)
}
library(GeoLight)
library(GeoLight)
library(MASS)
library(fields)
install.packages("fields")
library(maptools)
library(rgdal)
library(devtools)
install.packages("gitcredits")
##' @title Checkup of arguments in GeoLight tables
##' @param y GeoLigth data table.
##' @author Simeon Lisovski
i.argCheck <- function(y) {
if(any(sapply(y, function(x) class(x))=="data.frame")) {
ind01 <- which(sapply(y, function(x) class(x))=="data.frame")
if(!all(ind02 <- c("tFirst", "tSecond", "type")%in%names(y[[ind01]]))) {
whc <- paste("The following columns in data frame twl are missing with no default: ", paste(c("tFirst", "tSecond", "type")[!ind02], collapse = " and "), sep = "")
stop(whc , call. = F)
}
out <- y[[ind01]]
} else {
if(!all(c("tFirst", "tSecond", "type")%in%names(y))) {
ind03 <- c("tFirst", "tSecond", "type")%in%names(y)
stop(sprintf(paste(paste(c("tFirst", "tSecond", "type")[!ind03], collapse = " and "), "is missing with no default.")))
} else {
out <- data.frame(tFirst = y$tFirst, tSecond = y$tSecond, type = y$type)
}
}
if(any(c(class(out[,1])[1], class(out[,2])[1])!="POSIXct")) {
stop(sprintf("Date and time inforamtion (e.g. tFirst and tSecond) need to be provided as POSIXct class objects."), call. = F)
}
out
}
gh_token_help()
create_github_token()
gitcreds::gitcreds_set()
gitcreds::gitcreds_set()
library(GeoLight)
R.version
usethis::use_testthat()
usethis::use_test("Geolight.R")
?floor
?cat
?numeric
as.POSIXct()
as.POSIXct()
?as.POSIXct()
gl.loglik <- function(crds, Twilight, Rise, degElevation, parms, method, twilight = NULL) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = Rise, zenith = 90 - degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
if(is.null(twilight)) {
ll <- sum(stats::dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = F), na.rm = T)
} else {
if(twilight=="sr"){
ll <- sum(stats::dlnorm(diff.sr, parms[1], parms[2], log = F), na.rm = T)
}
if(twilight=="ss") {
ll <- sum(stats::dlnorm(diff.ss, parms[1], parms[2], log = F), na.rm = T)
}}
} else {
if(is.null(twilight)) {
ll <- sum(stats::dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = F), na.rm = T)
} else {
if(twilight=="sr"){
ll <- sum(stats::dgamma(diff.sr, parms[1], parms[2], log = F), na.rm = T)
}
if(twilight=="ss") {
ll <- sum(stats::dgamma(diff.ss, parms[1], parms[2], log = F), na.rm = T)
}}
}
return(ifelse(!is.infinite(abs(ll)), ll, -10000))
}
r <- rast(xmin=0, ncols=18, nrows=18)
plot(r)
r <- rast(xmin=0, ncols=18, nrows=18)
library(raster)
r <- rast(xmin=0, ncols=18, nrows=18)
library(raster)
library(terra)
r <- rast(xmin=0, ncols=18, nrows=18)
plot(r)
# generate points
set.seed(1)
p <- spatSample(r, 1000, xy=TRUE, replace=TRUE)
plot(p)
# rasterize points as a matrix
x <- rasterize(p, r, fun=sum)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(x)
plot(y)
plot(x)
r <- rast(xmin=0, ncols=18, nrows=18)
sum
# rasterize points as a matrix
x <- rasterize(p, r, fun=sum)
plot(p)
p
x
plot(x)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(y)
1:nrow(p)
y <- rasterize(p, r, value=1:nrow(p), fun=min)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=mean)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=sum)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(y)
# rasterize points as a SpatVector
pv <- vect(p)
pv
plot(pv)
xv <- rasterize(pv, r, fun=sum)
plot(pv)
xv <- rasterize(pv, r, fun=sum)
plot(xv)
xv <- rasterize(pv, r, fun=count)
plot(xv)
xv <- rasterize(pv, r, fun=min)
plot(xv)
xv <- rasterize(pv, r, fun=max)
plot(xv)
xv <- rasterize(pv, r, fun=sum)
plot(xv)
xv <- rasterize(pv, r)
plot(xv)
xv <- rasterize(pv, r, field = 1:nrow(pv))
plot(xv)
xv <- rasterize(pv, r, field = 1:nrow(pv))
plot(xv)
# Polygons
f <- system.file("ex/lux.shp", package="terra")
f
v <- vect(f)
v
r <- rast(v, ncols=75, nrows=100)
z <- rasterize(v, r, "NAME_2")
z
plot(z)
v
z <- rasterize(v, r, "AREA")
plot(z)
##'
##' data(hoopoe2)
##'   hoopoe2$tFirst <- as.POSIXct(hoopoe2$tFirst, tz = "GMT")
##'   hoopoe2$tSecond <- as.POSIXct(hoopoe2$tSecond, tz = "GMT")
##' residency <- changeLight(hoopoe2, quantile=0.9)
##'
##' @importFrom changepoint cpt.mean cpts.full pen.value.full
##' @importFrom stats na.omit quantile aggregate
##' @importFrom graphics abline axis layout mtext par plot rect
##' @export changeLight
changeLight <- function (tFirst, tSecond, type, twl, quantile = 0.9, rise.prob = NA,
set.prob = NA, days = 5, fixed = NULL, plot = TRUE, summary = TRUE) {
tab <- i.argCheck(as.list(environment())[sapply(environment(),
FUN = function(x) any(class(x) != "name"))])
if(is.null(fixed)) fixed <- matrix(FALSE, ncol = 2, nrow = nrow(tab))
tw <- data.frame(datetime = as.POSIXct(c(as.numeric(tab$tFirst), as.numeric(tab$tSecond)), origin = "1970-01-01", "GMT"),
type = c(tab$type, ifelse(tab$type == 1, 2, 1)), row = rep(1:nrow(tab), 2),
fixed = c(fixed[,1], fixed[,2]))
tw <- tw[!duplicated(tw$datetime), ]
tw <- tw[order(tw[, 1]), ]
hours <- as.numeric(format(tw[, 1], "%H")) + as.numeric(format(tw[,1], "%M"))/60
for (t in 1:2) {
cor <- rep(NA, 24)
for (i in 0:23) {
cor[i + 1] <- max(abs((c(hours[tw$type == t][1],
hours[tw$type == t]) + i)%%24 - (c(hours[tw$type == t],
hours[tw$type == t][length(hours)]) + i)%%24), na.rm = T)
}
hours[tw$type == t] <- (hours[tw$type == t] + (which.min(round(cor, 2))) - 1)%%24
}
sr <- tw[tw[, 2]==1, 1]
ss <- tw[tw[, 2]==2, 1]
rise <- hours[tw[, 2] == 1]
set  <- hours[tw[, 2] == 2]
CPs1 <- suppressWarnings(changepoint::cpt.mean(rise, method = "BinSeg",
Q = length(rise)/2, penalty = "Manual", pen.value = 0.001,
test.stat = "CUSUM", param.estimates = FALSE))
CPs2 <- suppressWarnings(changepoint::cpt.mean(set, method = "BinSeg",
Q = length(set)/2, penalty = "Manual", pen.value = 0.001,
test.stat = "CUSUM", param.estimates = FALSE))
N1 <- seq(1, length(rise))
N2 <- seq(1, length(set))
tab1 <- merge(data.frame(N = N1, prob = NA), data.frame(N = changepoint::cpts.full(CPs1)[nrow(changepoint::cpts.full(CPs1)),],
prob = changepoint::pen.value.full(CPs1)/2), by.x = "N", by.y = "N", all.x = T)[, -2]
tab1[is.na(tab1[, 2]), 2] <- 0
tab1[tw$fixed[tw$type==1],2] <- NA
tab2 <- merge(data.frame(N = N2, prob = NA), data.frame(N = changepoint::cpts.full(CPs2)[nrow(changepoint::cpts.full(CPs2)),],
prob = changepoint::pen.value.full(CPs2)/2), by.x = "N", by.y = "N",all.x = T)[, -2]
tab2[is.na(tab2[, 2]), 2] <- 0
tab2[tw$fixed[tw$type==2],2] <- NA
if (is.na(rise.prob) & is.na(set.prob)) {
rise.prob <- as.numeric(round(as.numeric(quantile(tab1[tab1[,
2] != 0, 2], probs = quantile, na.rm = TRUE)), digits = 5))
set.prob <- as.numeric(round(as.numeric(quantile(tab2[tab2[,
2] != 0, 2], probs = quantile, na.rm = TRUE)), digits = 5))
}
riseProb <- data.frame(time = tw[tw[, 2] == 1, 1], prob = tab1[,2])
setProb  <- data.frame(time = tw[tw[, 2] == 2, 1], prob = tab2[,2])
tmp02   <- data.frame(tab, rise.prob = apply(cbind(as.numeric(tab[,1]), as.numeric(tab[,2]), tab$type), 1,
function(x) ifelse(x[3]==1, riseProb$prob[which.min(abs(x[1]-as.numeric(riseProb$time)))],
riseProb$prob[which.min(abs(x[2]-as.numeric(riseProb$time)))])),
set.prob = apply(cbind(as.numeric(tab[,1]), as.numeric(tab[,2]), tab$type), 1,
function(x) ifelse(x[3]==2, setProb$prob[which.min(abs(x[1]-as.numeric(setProb$time)))],
setProb$prob[which.min(abs(x[2]-as.numeric(setProb$time)))])))
tmp02$cut   <- ifelse(apply(tmp02[, c("rise.prob", "set.prob", "type")], 1, function(x) any(ifelse(x[3]==1, x[1]>=rise.prob, x[2]>=set.prob), ifelse(x[3]==1, x[2]>=set.prob, x[1]>=rise.prob))), NA, TRUE)
tmp02$fixed <- apply(fixed, 1, function(x) any(x))
tmp02 <- cbind(tmp02, NA)
s <- 1
for (i in 1:nrow(tmp02)) {
if(i<nrow(tmp02)) if(tmp02$fixed[i+1] & !tmp02$fixed[i]) tmp02$cut[i] <- NA
if(i>1) if(tmp02$fixed[i-1] & !tmp02$fixed[i]) tmp02$cut[i] <- NA
if(tmp02[i, 'fixed']) {
if(i>1) if(is.na(tmp02$cut[i-1]) & !tmp02$fixed[i-1]) s <- s+1
tmp02[i, 8] <- s} else {
if(i%in%c(2:(nrow(tmp02)-1))){
if(is.na(tmp02[i - 1, 'cut']) & !is.na(tmp02[i, 'cut'])) {
s <- s + 1
tmp02[i, 8] <- s
}
if (!is.na(tmp02[i - 1, 'cut']) & !is.na(tmp02[i, 'cut']))
tmp02[i, 8] <- s
}
}
}
ind01 <- stats::aggregate(as.numeric(tmp02[!is.na(tmp02[,8]) & !tmp02$fixed,1]), by = list(tmp02[!is.na(tmp02[,8]) & !tmp02$fixed, 8]),
FUN =  function(x) (x[length(x)] - x[1])/60/60/24 > days)
tmp02[, 8] <- ifelse(tmp02[, 8]%in%c(ind01[ind01[,2],1], unique(tmp02[tmp02$fixed, 8])), tmp02[, 8], NA)
s <- 1
for (i in unique(tmp02[!is.na(tmp02[,8]),8])) {
tmp02[!is.na(tmp02[, 8]) & tmp02[, 8] == i, 8] <- s
s <- s + 1
}
t02 <- schedule(tmp02$tFirst, tmp02$tSecond, tmp02[,8])
arr <- tmp02[!is.na(tmp02[, 8]) & !duplicated(tmp02[, 8]),]
dep <- tmp02[!is.na(tmp02[, 8]) & !duplicated(tmp02[, 8], fromLast = T), ]
t02$P.start <- ifelse(arr$type==1, arr$rise.prob, arr$set.prob)
t02$P.end <- ifelse(dep$type==1, dep$rise.prob, dep$set.prob)
t02$Days <- apply(t02, 1, function(x) round(as.numeric(difftime(x[3], x[2], units = "days")), 1))
ds <- t02
out <- list(riseProb = tab1[, 2], setProb = tab2[, 2], rise.prob = rise.prob,
set.prob = set.prob, site = ifelse(is.na(tmp02[,8]), 0 , tmp02[,8]), migTable = ds)
if (plot) {
def.par <- par(no.readonly = TRUE)
nf <- layout(matrix(c(4, 1, 2, 3), nrow = 4, byrow = T),
heights = c(0.5, 1, 0.5, 0.5))
par(mar = c(2, 4.5, 2, 5), cex.lab = 1.5, cex.axis = 1.5,
bty = "o")
rise[tw$fixed[tw$type==1]] <- NA
plot(sr, rise,
type = "o", cex = 0.2, col = "firebrick",
ylab = "Sunrise (red)", xlim = range(sr), xaxt = "n")
par(new = T)
set[tw$fixed[tw$type==2]] <- NA
plot(ss, set, type = "o", cex = 0.2, col = "cornflowerblue",
xaxt = "n", yaxt = "n", xlab = "", ylab = "", xlim = range(ss))
axis(4)
mtext("Sunset (blue)", 4, line = 2.7, cex = 1)
axis(1, at = seq(min(ss), max(ss), by = (10 * 24 * 60 *
60)), labels = F)
axis(1, at = seq(min(ss), max(ss), by = (30 * 24 * 60 *
60)), lwd.ticks = 2, labels = trunc(seq(min(ss),
max(ss), by = (30 * 24 * 60 * 60)), "days"), cex.axis = 1)
par(mar = c(1.5, 4.5, 0.8, 5), bty = "n")
plot(sr, tab1[, 2], type = "h", lwd = 4, col = "firebrick",
ylab = "", xaxt = "n", xlim = range(sr), ylim = c(0,
max(na.omit(c(tab1[, 2], tab2[, 2])))))
if (is.numeric(rise.prob))
abline(h = rise.prob, lty = 2, lwd = 1.5)
opar <- par(mar = c(1.5, 4.5, 0.8, 5), bty = "n")
plot(ss, tab2[, 2], type = "h", lwd = 4, col = "cornflowerblue",
ylab = "", xaxt = "n", xlim = range(ss), ylim = c(0,
max(na.omit(c(tab1[, 2], tab2[, 2])))))
if (is.numeric(set.prob))
abline(h = set.prob, lty = 2, lwd = 1.5)
mtext("Probability of change", side = 2, at = max(na.omit(c(tab1[,
2], tab2[, 2]))), line = 3)
par(mar = c(1, 4.5, 1, 5), bty = "o")
mig <- out$site
mig[mig > 0] <- 1
plot(tab[, 1] + (tab[, 2] - tab[, 1])/2, ifelse(out$site >
0, 1, 0), type = "l", yaxt = "n", ylab = NA, ylim = c(0,1.5))
min.r <- stats::aggregate(as.numeric(tab$tFirst[out$site>0]), by = list(out$site[out$site>0]), FUN = function(x) min(x))
max.r <- stats::aggregate(as.numeric(tab$tFirst[out$site>0]), by = list(out$site[out$site>0]), FUN = function(x) max(x))
rect(min.r[,2], 1.1, max.r[,2], 1.4, col = "grey90", lwd = 0)
rect(min.r[,2], 1.1, max.r[,2], 1.4, col = ifelse(unique(out$site[out$site>0])%in%unique(tmp02[tmp02$fixed, 8]), "red", "transparent"),
density = 60)
par(def.par)
}
if (summary) {
i.sum.Cl(out)
}
return(out)
}
#' @param method \code{character} string; only \code{gamma} and \code{log-normal} are implemented.
#' @param parms a \code{vector} describing the two parameters of the error density distribution (defined by \code{method}).
#' @param xlim the longitudinal boundaries for which the likelihood will be calculated.
#' @param ylim the latitudinal boundaries for which the likelihood will be calculated.
#' @param res the spatial resolution in degrees.
#' @return A \code{list} with ...
#' @author Simeon Lisovski
#'
#' @export siteEstimate
#' @importFrom parallel makeCluster clusterSetRNGStream clusterExport clusterEvalQ parRapply stopCluster
siteEstimate <- function(tFirst, tSecond, type, twl,
degElevation,
method = "gamma", parms = c(3.3, 0.8),
xlim = c(-180, 180),
ylim = c(-90, 90), res = c(0.5, 0.5)) {
tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])
tw <- data.frame(Twilight = .POSIXct(c(tab$tFirst, tab$tSecond), "GMT"),
Rise = c(ifelse(tab$type==1, TRUE, FALSE), ifelse(tab$type == 1, FALSE, TRUE)))
tw <- tw[!duplicated(tw$Twilight),]
tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(stats::dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(stats::dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(tw$Twilight, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(tw, f = ifelse(1:nrow(tw)<min(eq.ind), 1, ifelse(1:nrow(tw)>max(eq.ind), 2, NA)))
} else {
twl.sp <- list(tw)
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
list(SunElevation = degElevation,
Estimate = out_A,
mlLoc = out_ML)
}
poc_red <- ggplot() +
geom_bar(aes(x = sr,
y = tab1[, 2]),
stat = "identity",
color = "firebrick") +
labs(title = "Probabiltiy of change"
x = "",
poc_red <- ggplot() +
geom_bar(aes(x = sr,
y = tab1[, 2]),
stat = "identity",
color = "firebrick") +
labs(title = "Probabiltiy of change",
x = "",
y = "") +
theme_bw() +
theme (panel.background = element_rect(fill = "white"),
axis.text.x = element_blank(),
panel.grid = element_blank(),
axis.title.y = element_text(hjust=-0.1)) +
scale_x_datetime(breaks = seq(min(sr),
max(sr),
length.out = 10),
date_labels = "%b %y")
print
print( hist_rect / (rise_set) / (poc_red) / (poc_blue))
