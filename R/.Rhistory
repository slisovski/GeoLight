write(" </Placemark>", filename, append = TRUE)
}
write("</Folder>", filename, append = TRUE)
write("<Placemark>", filename, append = TRUE)
write("  <name>Line Path</name>", filename, append = TRUE)
write("  <Style>", filename, append = TRUE)
write("    <LineStyle>", filename, append = TRUE)
write(paste("\t<color>", paste(noquote(usable.line.color[[1]][c(8,
9, 6, 7, 4, 5, 2, 3)]), collapse = ""), "</color>", sep = ""),
filename, append = TRUE)
write(paste("      <width>1</width>", sep = ""), filename,
append = TRUE)
write("    </LineStyle>", filename, append = TRUE)
write("  </Style>", filename, append = TRUE)
write("  <LineString>", filename, append = TRUE)
write("    <extrude>0</extrude>", filename, append = TRUE)
write("    <tessellate>1</tessellate>", filename, append = TRUE)
write(paste("\t<altitudeMode>clampToGround</altitudeMode>",
sep = ""), filename, append = TRUE)
write(paste("     <coordinates>", noquote(paste(longitude,
",", latitude, sep = "", collapse = " ")), "</coordinates>",
sep = ""), filename, append = TRUE)
write("    </LineString>", filename, append = TRUE)
write("</Placemark>", filename, append = TRUE)
write("</Document>", filename, append = TRUE)
write("</kml>", filename, append = TRUE)
}
#' Draw the positions and the trip on a map
#'
#' Draw a map (from the \code{R} Package \code{maps}) with calculated positions
#' connected by a line
#'
#'
#' @param crds a \code{SpatialPoints} or \code{matrix} object, containing x
#' and y coordinates (in that order).
#' @param equinox logical; if \code{TRUE}, the equinox period(s) is shown as a
#' broken blue line.
#' @param map.range some possibilities to choose defined areas (default:
#' "World").
#' @param ... Arguments to be passed to methods, such as graphical parameters (see par).
#' @param legend \code{logical}; if \code{TRUE}, a legend will be added to the plot.
#' @author Simeon Lisovski
#' @examples
#'
#' data(hoopoe2)
#' crds <- coord(hoopoe2, degElevation = -6)
#' tripMap(crds, xlim = c(-20,20), ylim = c(0,60), main="hoopoe2")
#'
#' @export tripMap
tripMap <- function(crds, equinox=TRUE, map.range=c("EuroAfrica","AustralAsia","America","World"), legend = TRUE, ...) {
args <- list(...)
if(all(map.range==c("EuroAfrica", "AustralAsia", "America", "World")) & sum(names(args)%in%c("xlim", "ylim"))!=2) {
range <- c(-180, 180, -80, 90)
}
if(all(map.range=="EuroAfrica")) range <- c(-24, 55, -55, 70)
if(all(map.range=="AustralAsia")) range <- c(60, 190, -55, 78)
if(all(map.range=="America")) range <- c(-170, -20, -65, 78)
if(all(map.range=="World")) range <- c(-180, 180, -75, 90)
if(sum(names(args)%in%c("xlim", "ylim"))==2) range <- c(args$xlim, args$ylim)
if(sum(names(args)%in%"add")==1) add <- args$add else add = FALSE
if(!add) {
opar <- par(mar = c(6,5,1,1))
plot(NA,xlim=c(range[1],range[2]),ylim=c(range[3],range[4]), xaxt = "n", yaxt = "n", xlab = "", ylab = "")
map(xlim=c(range[1],range[2]),ylim=c(range[3],range[4]), fill=T,lwd=0.01,col=c("grey90"),add=TRUE)
map(xlim=c(range[1],range[2]),ylim=c(range[3],range[4]),interior=TRUE,col=c("darkgrey"),add=TRUE)
mtext(ifelse(sum(names(args)%in%"xlab")==1, args$xlab, "Longitude"), side=1, line=2.2, font=3)
mtext(ifelse(sum(names(args)%in%"ylab")==1, args$ylab, "Latitude"), side=2, line=2.5, font=3)
map.axes()
mtext(ifelse(sum(names(args)%in%"main")==1, args$main, ""), line=0.6, cex=1.2)
}
points(crds,
pch = ifelse(sum(names(args)%in%"pch")==1, args$pch, 3),
cex = ifelse(sum(names(args)%in%"cex")==1, args$cex, 0.7))
lines(crds,
lwd = ifelse(sum(names(args)%in%"lwd")==1, args$lwd, 0.5),
col = ifelse(sum(names(args)%in%"col")==1, args$col, "grey10"))
if(equinox){
nrow <- 1
repeat{
while(is.na(crds[nrow,2])==FALSE) {
nrow <- nrow + 1
if(nrow==nrow(crds)) break
}
if(nrow==nrow(crds)) break
start   <- nrow-1
while(is.na(crds[nrow,2])) {
nrow <- nrow + 1
if(nrow==nrow(crds)) break
}
if(nrow==nrow(crds)) break
end    <- nrow
lines(c(crds[start,1], crds[end,1]),c(crds[start,2], crds[end,2]), col="blue", lwd=3, lty=1)
}
if(legend) legend("bottomright", lty=c(0,1,1), pch=c(3,-1,-1), lwd=c(1,0.5,3), col=c("black",ifelse(sum(names(args)%in%"col")==1, args$col, "grey10"),"blue"),c("Positions","Trip","Equinox"),bty="n",bg="grey90",border="grey90",cex=0.8)
} else {
if(legend) 	  legend("bottomright",lty=c(0,1),pch=c(3,-1),lwd=c(1,0.5),col=c("black",ifelse(sum(names(args)%in%"col")==1, args$col, "grey10"),"blue"),c("Positions","Trip"),bty="n",bg="grey90",border="grey90",cex=0.8)
}
if(!add) par(opar)
}
#' Calculate twilight events (sunrise/sunset) from light intensity measurements
#' over time
#'
#' Defines twilight events (sunrise/sunset) at times when the light intensity
#' measurements (\emph{light}) pass the defined light intensity threshold. An
#' interactive plot can be drawn to assess the calculations and improve e.g.
#' select only the realistic events.
#'
#'
#' @param datetime date and time of light intensity measurements e.g.
#' 2008-12-01 08:30 "UTC" (see:
#' \code{\link{as.POSIXct}},\link[=Sys.timezone]{time zones}).
#' @param light \code{numerical} value of the light intensity (usually
#' arbitrary units).
#' @param preSelection codelogical, if TRUE a pre selection of all calculated
#' twiligth events will be offered within the interactive process (ask=TRUE).
#' @param LightThreshold the light intensity threshold for the twilight event
#' calibration. If \code{Default}, it will be set slightly above (3 units) the
#' baseline level (measurement during the night).
#' @param maxLight if the geolocator record the maximum light value of a
#' certain time span, give the interval of maximum recordings in minutes (e.g.
#' 5).
#' @param ask \code{logical}, if TRUE the interactive plot will start after the
#' calculation.
#' @param nsee number of points to plot per screen.
#' @param allTwilights \code{logical}, if TRUE the function returns a list with
#' two tables
#' @return if allTwilights=FALSE, a \code{data frame}. Each row contains two
#' subsequent twilight events (\emph{tFirst, tSecond}) and \emph{type} defining
#' wether \emph{tFirst} refers to sunrise (1) or sunset (2). If
#' allTwilights=TRUE, a \code{list} with the data frame described in the
#' previous sentence and a data frame with all light intensities and a column
#' describing whether each row refers to sunrise (1), sunset (2) or to none of
#' these categories (0).
#' @note Depending on shading during light intensity measurements (e.g. due to
#' vegetation, weather, etc., see Lisovski et \emph{al.} 2012) the light
#' intensities may pass the light intensity threshold several times during the
#' day, resulting false sunrises and sunsets. It is highly recommended to check
#' the derived events visually (\code{ask=TRUE}).Twilight events can be deleted
#' and undeleted by clicking the (first) mouse button at the particular
#' position in the graph. The second mouse buttom (or esc) moves the time
#' series forward. Note, that a backward option is not included.
#' @author Simeon Lisovski
#' @export twilightCalc
twilightCalc <- function(datetime, light, LightThreshold=TRUE, preSelection=TRUE, maxLight=NULL, ask=TRUE, nsee=500, allTwilights=FALSE)
{
bas <- data.frame(datetime=as.POSIXct(as.character(datetime),"UTC"),light)
if (is.numeric(LightThreshold))
{
LightThreshold <- as.numeric(LightThreshold)
min <- min(bas$light)
} else {
# Basic level
r <- as.data.frame(table(bas$light))
nr <- as.numeric(which.max(r$Freq[as.numeric(r[,1])<mean(bas$light)]))
LightThreshold <- (as.numeric(as.character(r[nr,1])))+3
}
out <- i.preSelection(bas$datetime,bas$light, LightThreshold)[,-1]
if(!preSelection) out$mod <- 0
if(ask)
{
n   <- nrow(bas)
nn  <- n%/%nsee + 1
cutsub <- cut(1:n, nn)
picks <- NULL
for(i in 1:nn){
sub <- cutsub == levels(cutsub)[i]
repeat{
plot(bas[sub,1],bas[sub,2],type="o",cex=0.6,pch=20,ylab="Light intensity",xaxs="i",xaxt="n",xlab="",
main=paste(as.Date(min(bas[sub,1]))," to ", as.Date(max(bas[sub,1]))," (end: ",as.Date(max(bas[,1])),")",sep=""))
abline(h=LightThreshold,col="blue",lty=2)
abline(v=out[out$mod==0,1],col="orange",lty=ifelse(out[out$mod==0,2]==1,1,2))
points(out[,1],rep(LightThreshold,nrow(out[,])),col=ifelse(out$mod==0,"orange","grey"),pch=20,cex=0.8)
axis(1,at=out[seq(from=1,to=nrow(out),length.out=(nrow(out)%/%2)),1],
labels=substring(as.character(out[seq(from=1,to=nrow(out),length.out=(nrow(out)%/%2)),1]),6,16),cex=0.7)
legend("topright",lty=c(3,1,2),lwd=c(1.3,2,2),col=c("blue",rep("orange",2)),c("Light\nThreshold","sunrise","sunset"),cex=1,bg="white")
nr <- identify(out[,1],rep(LightThreshold,nrow(out)),n=1,plot=F)
ifelse(length(nr)>0,ifelse(out$mod[nr]==0,out$mod[nr]<-1,out$mod[nr]<-0),break)
}
}
cat("Thank you!\n\n")
graphics.off()
}
results <- list()
out <- subset(out,out$mod==0)[,-3]
raw <- data.frame(datetime=c(as.POSIXct(datetime,"UTC"),as.POSIXct(out$datetime,"UTC")),
light=c(light,rep(LightThreshold,nrow(out))),type=c(rep(0,length(datetime)),out$type))
raw <- raw[order(raw$type),]
raw <- raw[-which(duplicated(as.character(raw$datetime),fromLast=T)),]
raw <- raw[order(raw$datetime),]
results$allTwilights <- raw
opt <- data.frame(tFirst=as.POSIXct("1900-01-01 01:01","UTC"),tSecond=as.POSIXct("1900-01-01 01:01","UTC"),type=0)
row <- 1
for (k in 1:(nrow(out)-1))
{
if (as.numeric(difftime(out[k,1],out[k+1,1]))< 24 & out[k,1] != out[k+1,1])
{
opt[row,1] <- out[k,1]
opt[row,2] <- out[k+1,1]
opt[row,3] <- out$type[k]
row <- row+1
}
}
if(is.numeric(maxLight))
{
opt$tFirst[opt$type==2] <- opt$tFirst[opt$type==2] - (maxLight*60)
opt$tSecond[opt$type==1] <- opt$tSecond[opt$type==1] - (maxLight*60)
}
if(allTwilights) {
results$consecTwilights <- opt
return(results)
} else {
return (opt)}
}
#' Example data for calibration: Light intensities and twilight events
#'
#' Light intensity measurements over time (calib1) recorded at the rooftop of
#' the Swiss Ornithological Institute (Lon: 8.0, Lat: 47.01). Defined twilight
#' events from calib1 (calib2). These data serve as an example for calculating
#' the sun elevation angle of an additional data set, which is subsequently
#' used to calibrate the focal dataset.
#'
#' @name calib1
#' @docType data
#' @aliases calib1 calib2 calib
#' @references Lisovski, S., Hewson, C.M, Klaassen, R.H.G., Korner-Nievergelt,
#' F., Kristensen, M.W & Hahn, S. (2012) Geolocation by light: Accuracy and
#' precision affected by environmental factors. \emph{Methods in Ecology and
#' Evolution}, DOI: 10.1111/j.2041-210X.2012.00185.x.
#' @examples
#'
#' data(calib2)
#' getElevation(calib2$tFirst, calib2$tSecond, calib2$type, known.coord = c(8,47.01))
#'
NULL
#' Light intensity measurements over time recorded on a migratory bird
#'
#' Sunlight intensity measurements over time recorded during the first part of
#' the annual migration of a European Hoopoe (\cite{Upupa epops}). All
#' dates/times are measured in Universal Time Zone (UTC).
#'
#'
#' @name hoopoe1
#' @docType data
#' @format A table with 24474 rows and 2 columns, rows corresponding to light
#' measurements recorded in ten-minute intervals (datetime).
#' @source Baechler, E., Hahn, S., Schaub, M., Arlettaz, R., Jenni, L., Fox,
#' J.W., Afanasyev, V. & Liechti, F. (2010) Year-Round Tracking of Small
#' Trans-Saharan Migrants Using Light-Level Geolocators. \emph{Plos One},
#' \bold{5}.
NULL
#' Sunrise and sunset times: From light intensity measurement (hoopoe1)
#'
#' Sunrise and sunset times derived from light intensity measurements over time
#' (\code{\link{hoopoe1}}). The light measurements corresponding to the first
#' part of the annual migration of a European Hoopoe (\emph{Upupa epops}).
#'
#' @name hoopoe2
#' @docType data
#' @format A table with 340 rows and 3 columns. Each row corresponds to
#' subsequent twilight events ("tFirst" and "tSecond"). The third column
#' ("type") indicates weather the first event is sunrise (1) or sunset (2). All
#' dates/times are measured in Universal Time Zone (UTC).
#' @source Baechler, E., Hahn, S., Schaub, M., Arlettaz, R., Jenni, L., Fox,
#' J.W., Afanasyev, V. & Liechti, F. (2010) Year-Round Tracking of Small
#' Trans-Saharan Migrants Using Light-Level Geolocators. \emph{Plos One},
#' \bold{5}.
#' @examples
#'
#' data(hoopoe2)
#' coord <- with(hoopoe2, coord(tFirst,tSecond,type,degElevation=-6))
#' ## plot in a map using package maps
#' # par(oma=c(5,0,0,0))
#' # map(xlim=c(-20,40),ylim=c(-10,60),interior=F,col="darkgrey")
#' # map(xlim=c(-20,40),ylim=c(-10,60),boundary=F,lty=2,col="darkgrey",add=T)
#' # mtext(c("Longitude (degrees)","Latitude (degrees)"),side=c(1,2),line=c(2.2,2.5),font=3)
#' # map.axes()
#' # points(coord,col="brown",cex=0.5,pch=20)
#'
NULL
## Functions copied from SGAT and temporariliy included into GeoLight:
## 1) solar
## 2) zenith
## 3) refracted
## 4) twilight
## 5) geolight.convert
##' Calculate solar time, the equation of time and solar declination
##'
##' The solar time, the equation of time and the sine and cosine of
##' the solar declination are calculted for the times specified by
##' \code{tm} using the same methods as
##' \url{www.esrl.noaa.gov/gmd/grad/solcalc/}.
##' @title Solar Time and Declination
##' @param tm a vector of POSIXct times.
##' @return A list containing the following vectors.
##' \item{\code{solarTime}}{the solar time (degrees)}
##' \item{\code{eqnTime}}{the equation of time (minutes of time)}
##' \item{\code{sinSolarDec}}{sine of the solar declination}
##' \item{\code{cosSolarDec}}{cosine of the solar declination}
##' @seealso \code{\link{zenith}}
##' @examples
##' ## Current solar time
##' solar(Sys.time())
##' @export
solar <- function(tm) {
rad <- pi/180
## Time as Julian day (R form)
Jd <- as.numeric(tm)/86400.0+2440587.5
## Time as Julian century [G]
Jc <- (Jd-2451545)/36525
## The geometric mean sun longitude (degrees) [I]
L0 <- (280.46646+Jc*(36000.76983+0.0003032*Jc))%%360
## Geometric mean anomaly for the sun (degrees) [J]
M <- 357.52911+Jc*(35999.05029-0.0001537*Jc)
## The eccentricity of earth's orbit [K]
e <- 0.016708634-Jc*(0.000042037+0.0000001267*Jc)
## Equation of centre for the sun (degrees) [L]
eqctr <- sin(rad*M)*(1.914602-Jc*(0.004817+0.000014*Jc))+
sin(rad*2*M)*(0.019993-0.000101*Jc)+
sin(rad*3*M)*0.000289
## The true longitude of the sun (degrees) [M]
lambda0 <- L0 + eqctr
## The apparent longitude of the sun (degrees) [P]
omega <- 125.04-1934.136*Jc
lambda <- lambda0-0.00569-0.00478*sin(rad*omega)
## The mean obliquity of the ecliptic (degrees) [Q]
seconds <- 21.448-Jc*(46.815+Jc*(0.00059-Jc*(0.001813)))
obliq0 <- 23+(26+(seconds/60))/60
## The corrected obliquity of the ecliptic (degrees) [R]
omega <- 125.04-1934.136*Jc
obliq <- obliq0 + 0.00256*cos(rad*omega)
## The equation of time (minutes of time) [U,V]
y <- tan(rad*obliq/2)^2
eqnTime <- 4/rad*(y*sin(rad*2*L0) -
2*e*sin(rad*M) +
4*e*y*sin(rad*M)*cos(rad*2*L0) -
0.5*y^2*sin(rad*4*L0) -
1.25*e^2*sin(rad*2*M))
## The sun's declination (radians) [T]
solarDec <- asin(sin(rad*obliq)*sin(rad*lambda))
sinSolarDec <- sin(solarDec)
cosSolarDec <- cos(solarDec)
## Solar time unadjusted for longitude (degrees) [AB!!]
## Am missing a mod 360 here, but is only used within cosine.
solarTime <- ((Jd-0.5)%%1*1440+eqnTime)/4
#solarTime <- ((Jd-2440587.5)*1440+eqnTime)/4
## Return solar constants
list(solarTime=solarTime,
eqnTime=eqnTime,
sinSolarDec=sinSolarDec,
cosSolarDec=cosSolarDec)
}
##' Calculate the solar zenith angle for given times and locations
##'
##' \code{zenith} uses the solar time and declination calculated by
##' \code{solar} to compute the solar zenith angle for given times and
##' locations, using the same methods as
##' \url{www.esrl.noaa.gov/gmd/grad/solcalc/}.  This function does not
##' adjust for atmospheric refraction see \code{\link{refracted}}.
##' @title Solar Zenith Angle
##' @param sun list of solar time and declination computed by \code{solar}.
##' @param lon vector of longitudes.
##' @param lat vector latitudes.
##' @return A vector of solar zenith angles (degrees) for the given
##' locations and times.
##' @seealso \code{\link{solar}}
##' @examples
##' ## Approx location of Sydney Harbour Bridge
##' lon <- 151.211
##' lat <- -33.852
##' ## Solar zenith angle for noon on the first of May 2000
##' ## at the Sydney Harbour Bridge
##' s <- solar(as.POSIXct("2000-05-01 12:00:00","EST"))
##' zenith(s,lon,lat)
##' @export
zenith <- function(sun,lon,lat) {
rad <- pi/180
## Suns hour angle (degrees) [AC!!]
hourAngle <- sun$solarTime+lon-180
#hourAngle <- sun$solarTime%%360+lon-180
## Cosine of sun's zenith [AD]
cosZenith <- (sin(rad*lat)*sun$sinSolarDec+
cos(rad*lat)*sun$cosSolarDec*cos(rad*hourAngle))
## Limit to [-1,1] [!!]
cosZenith[cosZenith > 1] <- 1
cosZenith[cosZenith < -1] <- -1
## Ignore refraction correction
acos(cosZenith)/rad
}
##' Adjust the solar zenith angle for atmospheric refraction.
##'
##' Given a vector of solar zeniths computed by \code{\link{zenith}},
##' \code{refracted} calculates the solar zeniths adjusted for the
##' effect of atmospheric refraction.
##'
##' \code{unrefracted} is the inverse of \code{refracted}. Given a
##' (single) solar zenith adjusted for the effect of atmospheric
##' refraction, \code{unrefracted} calculates the solar zenith as
##' computed by \code{\link{zenith}}.
##'
##' @title Atmospheric Refraction
##' @param zenith zenith angle (degrees) to adjust.
##' @return vector of zenith angles (degrees) adjusted for atmospheric
##' refraction.
##' @examples
##' ## Refraction causes the sun to appears higher on the horizon
##' refracted(85:92)
##' ## unrefracted gives unadjusted zenith (see SGAT)
##'
##' @export
refracted <- function(zenith) {
rad <- pi/180
elev <- 90-zenith
te <- tan((rad)*elev)
## Atmospheric Refraction [AF]
r <- ifelse(elev>85,0,
ifelse(elev>5,58.1/te-0.07/te^3+0.000086/te^5,
ifelse(elev>-0.575,
1735+elev*(-518.2+elev*(103.4+elev*(-12.79+elev*0.711))),-20.772/te)))
## Corrected Zenith [90-AG]
zenith-r/3600
}
##' Estimate time of sunrsie or sunset for a given day and location
##'
##' \code{twilight} uses an iterative algorithm to estimate times of
##' sunrise and sunset.
##'
##' Note that these functions return the twilight that occurs on the
##' same date GMT as \code{tm}, and so sunset may occur before
##' sunrise, depending upon latitude.
##'
##' Solar declination and equation of time vary slowly over the day,
##' and so the values of the Solar declination and equation of time at
##' sunrise/sunset are well approximated by their values at 6AM/6PM
##' local time. The sun's hour angle and hence sunrise/sunset for the
##' required zenith can then be caclulates from these approximations.
##' The calculation is then repeated using the approximate
##' sunrise/sunset times to derive more accurate values of the Solar
##' declination and equation of time and hence better approximations
##' of sunrise/sunset.  The process is repreated and is accurate to
##' less than 2 seconds within 2 or 3 iterations.
##'
##' \code{sunrise} and \code{sunset} are simple wrappers for \code{twilight}.
##' @title Times of Sunrise and Sunset
##' @param tm vector of approximate times of twilight.
##' @param lon vector of longitudes.
##' @param lat vector of latitudes.
##' @param rise logical vector indicating whether to compute rise or set.
##' @param zenith the solar zenith angle that defines twilight.
##' @param iters number of iteratve refinements made to the initial
##' approximation.
##' @return a vector of twilight times.
##' @export
twilight <- function(tm,lon,lat,rise,zenith=96,iters=3) {
## Compute date
date <- as.POSIXlt(tm)
date$hour <- date$min <- date$sec <- 0
date <- as.POSIXct(date,"GMT")
lon <- (lon+180)%%360-180
## GMT equivalent of 6am or 6pm local time
twl <- date+240*(ifelse(rise,90,270)-lon)
## Iteratively improve estimate
for(k in seq_len(iters)) {
s <- solar(twl)
s$solarTime <- s$solarTime%%360
solarTime <- 4*twilight.solartime(s,lon,lat,rise,zenith)-s$eqnTime
twl <- date+60*solarTime
}
twl
}
twilight.solartime <- function(solar,lon,lat,rise,zenith=96) {
rad <- pi/180
cosz <- cos(rad*zenith)
cosHA <- (cosz-sin(rad*lat)*solar$sinSolarDec)/(cos(rad*lat)*solar$cosSolarDec)
## Compute the sun's hour angle from its declination for this location
hourAngle <- ifelse(rise,360,0)+ifelse(rise,-1,1)*suppressWarnings(acos(cosHA)/rad)
## Solar time of sunrise at this zenith angle, lon and lat
#(hourAngle+180-lon)%%360
#360*(solar$solarTime%/%360)+solarTime
solarTime <- (hourAngle+180-lon)%%360
(solarTime-solar$solarTime+180)%%360-180+solar$solarTime
}
i.geolight.convert <- function(tFirst,tSecond,type) {
tm <- .POSIXct(c(as.POSIXct(tFirst,"GMT"),
as.POSIXct(tSecond,"GMT")),"GMT")
keep <- !duplicated(tm)
tm <- tm[keep]
rise <- c(type==1,type!=1)[keep]
ord <- order(tm)
data.frame(Twilight=tm[ord],Rise=rise[ord])
}
##' Convert GeoLight data
##'
##' This function converts from the tFirst, tSecond format used by
##' GeoLight to the twilight, rise format used by Stella and Estelle.
##' @title Convert GeoLight Format
##' @param tFirst times of first twilight.
##' @param tSecond times of second twilight.
##' @param type type of twilight.
##' @return A data frame with columns
##' \item{\code{twilight}}{times of twilight as POSIXct objects.}
##' \item{\code{rise}}{logical vector indicating which twilights are sunrise.}
##' @export
geolight.convert <- function(tFirst,tSecond,type) {
tm <- .POSIXct(c(as.POSIXct(tFirst,"GMT"),
as.POSIXct(tSecond,"GMT")),"GMT")
keep <- !duplicated(tm)
tm <- tm[keep]
rise <- c(type==1,type!=1)[keep]
ord <- order(tm)
data.frame(Twilight=tm[ord],Rise=rise[ord])
}
data(hoopoe2)
