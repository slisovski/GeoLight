which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
twl.sp
loglik <- function(crds, twl, degElevation, method, parms) {
t.tw <- twilight(twl$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(twl$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(twl$Twilight[twl$Rise], t.tw[twl$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!twl$Rise], twl$Twilight[!twl$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
twl.sp
loglik <- function(crds, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik", "twl.sp"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
i <- 1
nll <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
nll <- lapply(twl.sp, fun = function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
nll <- lapply(twl.sp, FUN = function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, degElevation = degElevation[i], method = method, parms = parms))
j <- 1
loglik <- function(crds, x, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, x = twl.sp[[j]], degElevation = degElevation[i], method = method, parms = parms)
twl.sp[[j]]
loglik <- function(crds, x, degElevation, method, parms) {
t.tw <- twilight(x$Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(x$Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(x$Twilight[x$Rise], t.tw[x$Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!x$Rise], x$Twilight[!x$Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
loglik
twl.sp[[j]]
# tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
parallel::stopCluster(mycl)
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = twl.sp[[j]]$Twilight, Rise = twl.sp[[j]]$Rise, degElevation = degElevation[i], method = method, parms = parms)
nll
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
i
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
parallel::stopCluster(mycl)
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
nll   <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
str(nll)
do.call("cbind", nll)
apply(do.call("cbind", nll0), 1, function(x) if(any(is.infinite(x)), Inf, sum(x))
apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
nll0   <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(any(is.infinite(x)), Inf, sum(x)))
out_A[,,i] <- matrix((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T), ncol = length(lon), nrow = length(lat), byrow = T)
(max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
out_ML
any(!is.finite(out_A[,,i]))
out_A[,,i]
!is.finite(out_A[,,i])
!is.finite(out_A[,,i]))
is.finite(out_A[,,i])
any(!is.finite(abs(out_A[,,i])))
any(is.finite(abs(out_A[,,i])))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
nll
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
any(is.finite(abs(out_A[,,i])))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
points(out_ML[3,1], out_ML[3,2], pch = 21, bg = "white")
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
res = c(.5,.5)
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
# arrows(out_ML[1,1], out_ML[1,2], out_ML[3,1], out_ML[3,2], code = 3, length = 0.05, lwd = 2, angle = 90)
# points(out_ML[2,1], out_ML[2,2], pch = 21, bg = "white")
plot(as.numeric(format(twl$Twilight0, "%H")) + as.numeric(format(twl$Twilight0, "%M"))/60 + as.numeric(format(twl$Twilight0, "%S"))/60/60,
ylim = c(-1, 15), pch = 16, cex = 0.5, col = ifelse(twl$Rise, "red", "blue"))
points(as.numeric(format(twl$Twilight, "%H")) + as.numeric(format(twl$Twilight, "%M"))/60 + as.numeric(format(twl$Twilight, "%S"))/60/60,
pch = "x", col = ifelse(twl$Rise, "red", "blue"), cex = 0.5)
degElevation = seq(-8, -4, by = 0.5)
degElevation
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(twl$Twilight0, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(twl, f = ifelse(1:nrow(twl)<min(eq.ind), 1, ifelse(1:nrow(twl)>max(eq.ind), 2, NA)))
} else {
twl.sp <- twl
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,2], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,3], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,4], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(raster(out_A[,,5], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
out_ML
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML))
points(out_ML, pch = 16, col = topo.colors(nrow(out_ML)))
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
plot(wrld_simpl, add = T)
abline(h = crds[2], v = crds[1], lty = 3)
plot(raster(out_A[,,1], xmn = xlim[1], xmx = xlim[2], ymn = ylim[1], ymx = ylim[2]),
col =  rev(terrain.colors(200)), legend = F, xlim = xlim, ylim = ylim)
library(GeoLight)
siteEstimate()
siteEstimate
siteEstimate <- function(tFirst, tSecond, type, twl,
degElevation,
method = "gamma", parms = c(3.3, 0.8),
xlim = c(-180, 180),
ylim = c(-90, 90), res = c(0.5, 0.5)) {
tab <- i.argCheck(as.list(environment())[sapply(environment(), FUN = function(x) any(class(x)!='name'))])
tw <- data.frame(Twilight = .POSIXct(c(tab$tFirst, tab$tSecond), "GMT"),
Rise = c(ifelse(tab$type==1, TRUE, FALSE), ifelse(tab$type == 1, FALSE, TRUE)))
tw <- tw[!duplicated(tw$Twilight),]
tw <- tw[order(tw[,1]),]
loglik <- function(crds, Twilight, Rise, degElevation, method, parms) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = ifelse(Rise, TRUE, FALSE), zenith = 90-degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
return(-sum(dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
if(method=="gamma") {
return(-sum(dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = T), na.rm = T))
}
}
lon <- seq(xlim[1], xlim[2], by = res[1])
lat <- rev(seq(ylim[1], ylim[2], by = res[2]))
crdsm <- data.frame(lon = rep(lon, length(lat)),
lat = rep(lat, each = length(lon)))
out_A  <- array(dim = c(length(lat), length(lon), length(degElevation)))
colnames(out_A) <- lon
rownames(out_A) <- lat
out_ML <- matrix(NA, ncol = 2, nrow = length(degElevation))
eq.ind <- which(format(tw$Twilight, "%m/%d")%in%c("03/21", "09/21"))
if(length(eq.ind)>0) {
twl.sp <- split(tw, f = ifelse(1:nrow(tw)<min(eq.ind), 1, ifelse(1:nrow(tw)>max(eq.ind), 2, NA)))
} else {
twl.sp <- list(tw)
}
mycl <- parallel::makeCluster(parallel::detectCores()-1)
tmp  <- parallel::clusterSetRNGStream(mycl)
tmp  <- parallel::clusterExport(mycl, c("loglik"), envir=environment())
tmp  <- parallel::clusterEvalQ(mycl, library("GeoLight"))
for(i in 1:length(degElevation)) {
nll0  <- lapply(twl.sp, function(x) parallel::parRapply(mycl, crdsm, FUN = loglik, Twilight = x$Twilight, Rise = x$Rise,
degElevation = degElevation[i], method = method, parms = parms))
nll   <- apply(do.call("cbind", nll0), 1, function(x) ifelse(all(is.infinite(abs(x))), Inf, sum(x)))
out_A[,,i] <- matrix(suppressWarnings((max(nll[is.finite(nll)])-nll)/sum(nll[is.finite(nll)], na.rm = T)),
ncol = length(lon), nrow = length(lat), byrow = T)
if(any(is.finite(abs(out_A[,,i])))) {
out_ML[i,] <- cbind(as.numeric(colnames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[2]]),
as.numeric(rownames(out_A)[which(out_A[,,i] == max(out_A[,,i], na.rm = T), arr.ind = TRUE)[1]]))
}
}
parallel::stopCluster(mycl)
list(SunElevation = degElevation,
Estimate = out_A,
mlLoc = out_ML)
}
library(GeoLight)
library(GeoLight)
library(MASS)
library(fields)
install.packages("fields")
library(maptools)
library(rgdal)
library(devtools)
install.packages("gitcredits")
##' @title Checkup of arguments in GeoLight tables
##' @param y GeoLigth data table.
##' @author Simeon Lisovski
i.argCheck <- function(y) {
if(any(sapply(y, function(x) class(x))=="data.frame")) {
ind01 <- which(sapply(y, function(x) class(x))=="data.frame")
if(!all(ind02 <- c("tFirst", "tSecond", "type")%in%names(y[[ind01]]))) {
whc <- paste("The following columns in data frame twl are missing with no default: ", paste(c("tFirst", "tSecond", "type")[!ind02], collapse = " and "), sep = "")
stop(whc , call. = F)
}
out <- y[[ind01]]
} else {
if(!all(c("tFirst", "tSecond", "type")%in%names(y))) {
ind03 <- c("tFirst", "tSecond", "type")%in%names(y)
stop(sprintf(paste(paste(c("tFirst", "tSecond", "type")[!ind03], collapse = " and "), "is missing with no default.")))
} else {
out <- data.frame(tFirst = y$tFirst, tSecond = y$tSecond, type = y$type)
}
}
if(any(c(class(out[,1])[1], class(out[,2])[1])!="POSIXct")) {
stop(sprintf("Date and time inforamtion (e.g. tFirst and tSecond) need to be provided as POSIXct class objects."), call. = F)
}
out
}
gh_token_help()
create_github_token()
gitcreds::gitcreds_set()
gitcreds::gitcreds_set()
library(GeoLight)
R.version
usethis::use_testthat()
usethis::use_test("Geolight.R")
?floor
?cat
?numeric
as.POSIXct()
as.POSIXct()
?as.POSIXct()
gl.loglik <- function(crds, Twilight, Rise, degElevation, parms, method, twilight = NULL) {
t.tw <- twilight(Twilight, lon = crds[1], lat = crds[2],
rise = Rise, zenith = 90 - degElevation,
iters = 6)
diff.sr <- as.numeric(difftime(Twilight[Rise], t.tw[Rise], units = "mins"))
diff.ss <- as.numeric(difftime(t.tw[!Rise], Twilight[!Rise], units = "mins"))
if(method=="log-norm") {
if(is.null(twilight)) {
ll <- sum(stats::dlnorm(c(diff.sr, diff.ss), parms[1], parms[2], log = F), na.rm = T)
} else {
if(twilight=="sr"){
ll <- sum(stats::dlnorm(diff.sr, parms[1], parms[2], log = F), na.rm = T)
}
if(twilight=="ss") {
ll <- sum(stats::dlnorm(diff.ss, parms[1], parms[2], log = F), na.rm = T)
}}
} else {
if(is.null(twilight)) {
ll <- sum(stats::dgamma(c(diff.sr, diff.ss), parms[1], parms[2], log = F), na.rm = T)
} else {
if(twilight=="sr"){
ll <- sum(stats::dgamma(diff.sr, parms[1], parms[2], log = F), na.rm = T)
}
if(twilight=="ss") {
ll <- sum(stats::dgamma(diff.ss, parms[1], parms[2], log = F), na.rm = T)
}}
}
return(ifelse(!is.infinite(abs(ll)), ll, -10000))
}
r <- rast(xmin=0, ncols=18, nrows=18)
plot(r)
r <- rast(xmin=0, ncols=18, nrows=18)
library(raster)
r <- rast(xmin=0, ncols=18, nrows=18)
library(raster)
library(terra)
r <- rast(xmin=0, ncols=18, nrows=18)
plot(r)
# generate points
set.seed(1)
p <- spatSample(r, 1000, xy=TRUE, replace=TRUE)
plot(p)
# rasterize points as a matrix
x <- rasterize(p, r, fun=sum)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(x)
plot(y)
plot(x)
r <- rast(xmin=0, ncols=18, nrows=18)
sum
# rasterize points as a matrix
x <- rasterize(p, r, fun=sum)
plot(p)
p
x
plot(x)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(y)
1:nrow(p)
y <- rasterize(p, r, value=1:nrow(p), fun=min)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=mean)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=sum)
plot(y)
y <- rasterize(p, r, value=1:nrow(p), fun=max)
plot(y)
# rasterize points as a SpatVector
pv <- vect(p)
pv
plot(pv)
xv <- rasterize(pv, r, fun=sum)
plot(pv)
xv <- rasterize(pv, r, fun=sum)
plot(xv)
xv <- rasterize(pv, r, fun=count)
plot(xv)
xv <- rasterize(pv, r, fun=min)
plot(xv)
xv <- rasterize(pv, r, fun=max)
plot(xv)
xv <- rasterize(pv, r, fun=sum)
plot(xv)
xv <- rasterize(pv, r)
plot(xv)
xv <- rasterize(pv, r, field = 1:nrow(pv))
plot(xv)
xv <- rasterize(pv, r, field = 1:nrow(pv))
plot(xv)
# Polygons
f <- system.file("ex/lux.shp", package="terra")
f
v <- vect(f)
v
r <- rast(v, ncols=75, nrows=100)
z <- rasterize(v, r, "NAME_2")
z
plot(z)
v
z <- rasterize(v, r, "AREA")
plot(z)
